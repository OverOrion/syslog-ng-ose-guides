<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter SYSTEM "../../xml-stylesheet/pdf/dtd/docbookx.dtd"
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]> 
<chapter id="chapter-routing-filters">
    <title>Routing messages: log paths<phrase condition="pe">, reliability,</phrase> and filters</title>
<!-- FIXME jumplist -->
        <section id="logpath">
        <title>Log paths</title>
        <indexterm significance="preferred">
            <primary>log paths</primary>
        </indexterm>
        <para>Log paths determine what happens with the incoming log messages. Messages coming from
            the sources listed in the log statement and matching all the filters are sent to the
            listed destinations.</para>
        <para>To define a log path, add a log statement to the syslog-ng configuration file using
            the following syntax:</para>
        <indexterm>
            <primary>log paths</primary>
            <secondary>defining</secondary>
        </indexterm>
        <synopsis id="log_path_synopsis">log {
    source(s1); source(s2); ... 
    optional_element(filter1|parser1|rewrite1); optional_element(filter2|parser2|rewrite2);... 
    destination(d1); destination(d2); ... 
    flags(flag1[, flag2...]);
    };</synopsis>
        <warning>
            <para>Log statements are processed in the order they appear in the configuration file,
                thus the order of log paths may influence what happens to a message, especially when
                using filters and log flags. </para>
        </warning>
        <example id="log_statement_example">
            <title>A simple log statement</title>
            <para>The following log statement sends all messages arriving to the localhost to a
                remote server.</para>
            <synopsis>source s_localhost { tcp(ip(127.0.0.1) port(1999) ); };
destination d_tcp { tcp("10.1.2.3" port(1999); localport(999)); };
log { source(s_localhost); destination(d_tcp); };</synopsis>
        </example>
        <para>All matching log statements are processed by default, and the messages are sent to
                <emphasis>every</emphasis> matching destination by default. So a single log message
            might be sent to the same destination several times, provided the destination is listed
            in several log statements, and it can be also sent to several different destinations.</para>
        <indexterm>
            <primary>log paths</primary>
            <secondary>flags</secondary>
        </indexterm>
        <indexterm>
            <primary>flags</primary>
        </indexterm>
        <para>This default behavior can be changed using the <parameter>flags()</parameter>
            parameter. Flags apply to individual log paths; they are not global options. The
            following flags available in syslog-ng: </para>
        <itemizedlist>
            <listitem>
                <para><emphasis>final</emphasis>: Do not send the messages processed by this log
                    path to any further destination.</para>
            </listitem>
            <listitem>
                <para><emphasis>fallback</emphasis>: Process messages that were not processed by
                    other log paths.</para>
            </listitem>
            <listitem>
                <para><emphasis>catchall</emphasis>: Process every message, regardless of its source
                    or if it was already processed by other log paths.</para>
            </listitem>
            <listitem>
                <para><emphasis>flow-control</emphasis>: Stop reading messages from the source if
                    the destination cannot accept them. For details, see <xref linkend="concepts_flow_control"
                />.</para>
            </listitem>
        </itemizedlist>
<!--        <warning>
                <xi:include href="chapter-routing-messages.xml" xpointer="xpointer(//warning[@id = 'warning_embedded_log_flags']/node() )" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </warning>
        <example>
                <xi:include href="chapter-routing-messages.xml" xpointer="xpointer(//example[@id = 'example_logpath_flags']/node() )" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </example>-->
        <para>For details on the individual flags, see <xref linkend="reference_logflags"/>. The
            effect and use of the <parameter>flow-control</parameter> flag is detailed in <xref
                linkend="concepts_flow_control"/>.</para>

    <section id="concepts_embedded_logpaths">
        <title>Embedded log statements</title>
        <indexterm>
            <primary>embedded log statements</primary>
        </indexterm>
        <indexterm>
            <primary>log pipes</primary>
            <secondary>embedded log statements</secondary>
        </indexterm>
        <indexterm significance="preferred">
            <primary>log statements</primary>
            <secondary>embedded</secondary>
        </indexterm>
        <para>Starting from version 3.0, syslog-ng can handle embedded log statements (also
            called log pipes). Embedded log statements are useful for creating complex,
            multi-level log paths with several destinations and use filters, parsers, and
            rewrite rules.</para>
        <para>For example, if you want to filter your incoming messages based on the facility
            parameter, and then use further filters to send messages arriving from different
            hosts to different destinations, you would use embedded log statements.</para>
        <figure>
            <title>Embedded log statement</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center"
                        fileref="syslog-ng-embedded-log-statement-2.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG"
                        fileref="&imgroot;/syslog-ng-embedded-log-statement-2.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Embedded log statements include sources &mdash; and usually filters, parsers,
            rewrite rules, or destinations &mdash; and other log statements that can include
            filters, parsers, rewrite rules, and destinations. The following rules apply to
            embedded log statements:</para>
        <itemizedlist>
            <listitem>
                <para>Only the beginning (also called top-level) log statement can include
                    sources.</para>
            </listitem>
            <listitem>
                <para>Embedded log statements can include multiple log statements on the same
                    level (that is, a top-level log statement can include two or more log
                    statements).</para>
            </listitem>
            <listitem>
                <para>Embedded log statements can include several levels of log statements
                    (that is, a top-level log statement can include a log statement that includes
                    another log statement, and so on).</para>
            </listitem>
            <listitem>
                <para>Only another log statement can follow an embedded log statement, filters
                    or other rules cannot.</para>
            </listitem>
            <listitem>
                <para>Embedded log statements that are on the same level receive the same
                    messages from the higher-level log statement. For example, if the top-level
                    log statement includes a filter, the lower-level log statements receive only
                    the messages that pass the filter.</para>
            </listitem>
        </itemizedlist>
        <figure>
            <title>Embedded log statements</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center"
                        fileref="syslog-ng-embedded-log-statement.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG"
                        fileref="&imgroot;/syslog-ng-embedded-log-statement.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Embedded log filters can be used to optimize the processing of log messages, for
            example, to re-use the results of filtering and rewriting operations.</para>
        <section id="configuring_embedded_logpaths">
            <title>Using embedded log statements</title>
            <para>Embedded log statements (for details, see <xref linkend="concepts_embedded_logpaths"/>) re-use
                the results of processing messages (for example the results of filtering or rewriting) to
                create complex log paths. Embedded log statements use the same syntax as regular log
                statements, but they cannot contain additional sources. To define embedded log
                statements, use the following syntax:</para>
            <synopsis id="log_path_synopsis_embedded">log {
    source(s1); source(s2); ... 
    
    optional_element(filter1|parser1|rewrite1); 
    optional_element(filter2|parser2|rewrite2);... 
    
    destination(d1); destination(d2); ... 
    
    #embedded log statement
    log
        {
        optional_element(filter1|parser1|rewrite1); 
        optional_element(filter2|parser2|rewrite2);
        ... 
        destination(d1); destination(d2); ...
        #another embedded log statement
        log
        {
            optional_element(filter1|parser1|rewrite1); 
            optional_element(filter2|parser2|rewrite2);
            ... 
            destination(d1); destination(d2); ...};
        };    
    #set flags after the embedded log statements
    flags(flag1[, flag2...]); 
        };</synopsis>
<!--            <warning>
                <xi:include href="chapter-routing-messages.xml" xpointer="xpointer(//warning[@id = 'warning_embedded_log_flags']/node() )" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </warning>
-->
            <example id="example_logpath_embedded">
                <title>Using embedded log paths</title>
                <para>The following log path sends every message to the
                    <parameter>d_file1</parameter> and the <parameter>d_file2</parameter>
                    destinations.</para>
                <synopsis>log { source(s_localhost); destination(d_file1); destination(d_file2); };</synopsis>
                <para>The next example is equivalent with the one above, but uses an embedded log
                    statement.</para>
                <synopsis>log { source(s_localhost); destination(d_file1); 
                    log {destination(d_file2); };
};</synopsis>
                <para>The following example sends every message coming from the host
                        <parameter>192.168.1.1</parameter> into the <parameter>d_file1</parameter>
                    destination, and sends every message coming from the host
                    <parameter>192.168.1.1</parameter> and containing the string
                    <parameter>example</parameter> into the <parameter>d_file2</parameter>
                    destination.</para>
                <synopsis>log { source(s_localhost); host(192.168.1.); destination(d_file1); 
                    log {message("example"); destination(d_file2); };
};</synopsis>
                <para>The following example collects logs from multiple source groups and uses the
                        <parameter>source()</parameter> filter in the embedded log statement to
                    select messages of the <parameter>s_network</parameter> source group.</para>
                <synopsis>log { source(s_localhost); source(s_network); destination(d_file1); 
                    log {source(s_network); destination(d_file2); };
                    };</synopsis>
            </example>
        </section>
        </section>
        <section id="reference_logflags">
            <title>Log path flags</title>
            <para>Flags influence the behavior of syslog-ng, and the way it processes messages. The
                following flags may be used in the log paths, as described in <xref linkend="logpath"/>.</para>
            <table id="logflags">
                <title>Log statement flags</title>
                <indexterm>
                    <primary>log paths</primary>
                    <secondary>flags</secondary>
                </indexterm>
                <indexterm>
                    <primary>flags</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>flags</primary>
                </indexterm>
                <tgroup cols="2">
                        <colspec colnum="1" colwidth="40pt"/>
                    <thead>
                        <row>
                            <entry>Flag</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <indexterm type="parameter">
                                <primary>catchall</primary>
                            </indexterm>
                            <entry>catchall</entry>
                            <entry>This flag means that the source of the message is ignored, only the
                                filters are taken into account when matching messages. A log statement
                                using the <parameter>catchall</parameter> flag processes every message
                                that arrives to any of the defined sources.</entry>
                        </row>
                        <row>
                            <indexterm type="parameter">
                                <primary>fallback</primary>
                            </indexterm>
                            <entry>fallback</entry>
                            <entry>This flag makes a log statement 'fallback'. Fallback log statements
                                process messages that were not processed by other, 'non-fallback' log
                                statements. </entry>
                        </row>
                        <row>
                            <indexterm type="parameter">
                                <primary>final</primary>
                            </indexterm>
                            <entry>final</entry>
                            <entry>This flag means that the processing of log messages processed by the
                                log statement ends here, other log statements appearing later in the
                                configuration file will not process the messages processed by the log
                                statement labeled as 'final'. Note that this does not necessarily mean
                                that matching messages will be stored only once, as there can be
                                matching log statements processed prior the current one. </entry>
                        </row>
                        <row>
                            <indexterm type="parameter">
                                <primary>flow-control</primary>
                            </indexterm>
                            <entry>flow-control</entry>
                            <entry>Enables flow-control to the log path, meaning that syslog-ng will
                                stop reading messages from the sources of this log statement if the
                                destinations are not able to process the messages at the required speed.
                                If disabled, syslog-ng will drop messages if the destination queues are
                                full. If enabled, syslog-ng will only drop messages if the destination
                                queues/window sizes are improperly sized. For details, see <xref linkend="concepts_flow_control"/>.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <warning id="warning_embedded_log_flags">
                <para>The <parameter>final</parameter>, <parameter>fallback</parameter>, and
                    <parameter>catchall</parameter> flags apply only for the top-level log paths,
                    they have no effect on embedded log paths.</para>
            </warning>
            <example id="example_logpath_flags">
                <title>Using log path flags</title>
                <!--<para>The following log path processes every message received to the
                    <parameter>s_localhost</parameter> source that was not processed by earlier log
                    paths. As syslog-ng processes log paths in the order they appear in the
                    configuration file, place such log paths at the end of the file. A typical situation
                    is to use filters to select the most important messages and send them to specific
                    destinations, and process the remaining messages with a fallback log path.</para>
                    <synopsis>.
                    .
                    .
                    log { source(s_localhost); destination(d_tcp); flags(fallback); };</synopsis>-->
                <para>Let's suppose that you have two hosts (<parameter>myhost_A</parameter> and
                    <parameter>myhost_B</parameter>) that run two applications each
                    (<parameter>application_A</parameter> and <parameter>application_B</parameter>),
                    and you collect the log messages to a central syslog-ng server. On the server, you
                    create two log paths:</para>
                <itemizedlist>
                    <listitem>
                        <para>one that processes only the messages sent by
                            <parameter>myhost_A</parameter>; and</para>
                    </listitem>
                    <listitem>
                        <para>one that processes only the messages sent by
                            <parameter>application_A</parameter>.</para>
                    </listitem>
                </itemizedlist>
                <para>This means that messages sent by <parameter>application_A</parameter> running on
                    <parameter>myhost_A</parameter> will be processed by both log paths, and the
                    messages of <parameter>application_B</parameter> running on
                    <parameter>myhost_B</parameter> will not be processed at all.</para>
                <itemizedlist>
                    <listitem>
                        <para>If you add the <parameter>final</parameter> flag to the first log path,
                            then only this log path will process the messages of
                            <parameter>myhost_A</parameter>, so the second log path will receive only
                            the messages of <parameter>application_A</parameter> running on
                            <parameter>myhost_B</parameter>. </para>
                    </listitem>
                    <listitem>
                        <para>If you create a third log path that includes the
                            <parameter>fallback</parameter> flag, it will process the messages not
                            processed by the first two log paths, in this case, the messages of
                            <parameter>application_B</parameter> running on
                            <parameter>myhost_B</parameter>.</para>
                    </listitem>
                    <listitem>
                        <para>Adding a fourth log path with the <parameter>catchall</parameter> flag
                            would process every message received by the syslog-ng server.</para>
                        <synopsis>log { source(s_localhost); destination(d_file); flags(catchall); };</synopsis>
                    </listitem>
                </itemizedlist>
            </example>
        </section>
    </section>
    <section id="concepts_flow_control">
        <title>Managing incoming and outgoing messages with flow-control</title>
        <indexterm>
            <primary>log paths</primary>
            <secondary>flow-control</secondary>
        </indexterm>
        <indexterm>
            <primary>flow-control</primary>
        </indexterm>
        <indexterm>
            <primary>preventing message loss</primary>
            <secondary>flow-control</secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary>
                <parameter>log_fetch_limit()</parameter>
            </secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary>
                <parameter>log_fifo_size()</parameter>
            </secondary>
        </indexterm>
        <para>This section describes the internal message-processing model of syslog-ng, as well as
            the flow-control feature that can prevent message losses. To use flow-control, the
                <parameter>flow-control</parameter> flag must be enabled for the particular log
            path.</para>
        <para>The syslog-ng application monitors (polls) the sources defined in its configuration
            file, periodically checking each source for messages. When a log message is found in one
            of the sources, syslog-ng polls every source and reads the available messages. These
            messages are processed and put into the output buffer of syslog-ng (also called fifo).
            From the output buffer, the operating system sends the messages to the appropriate
            destinations.</para>
        <para>In large-traffic environments many messages can arrive during a single poll loop,
            therefore syslog-ng reads only a fixed number of messages from each source. The
                <parameter>log_fetch_limit()</parameter> option specifies the number of messages
            read during a poll loop from a single source.</para>
        <figure>
            <title>Managing log messages in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center" fileref="io1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io1.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <note>
            <para>The <parameter>log_fetch_limit()</parameter> parameter can be set as a global
                option, or for every source individually.</para>
        </note>
        <indexterm>
            <primary>output buffer</primary>
        </indexterm>
        <para>Every destination has its own output buffer. The output buffer is needed because the
            destination might not be able to accept all messages immediately. The
                <parameter>log_fifo_size()</parameter> parameter sets the size of the output buffer.
            The output buffer must be larger than the <parameter>log_fetch_limit()</parameter> of
            the sources, to ensure that every message read during the poll loop fits into the output
            buffer. If the log path sends messages to a destination from multiple sources, the
            output buffer must be large enough to store the incoming messages of every source.</para>
        <para>TCP and unix-stream sources can receive the logs from several incoming connections
            (for example many different clients or applications). For such sources, syslog-ng reads
            messages from every connection, thus the <parameter>log_fetch_limit()</parameter>
            parameter applies individually to every connection of the source.</para>
        <indexterm>
            <primary>parameters</primary>
            <secondary>
                <parameter>log_iw_size()</parameter>
            </secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary>
                <parameter>max_connections()</parameter>
            </secondary>
        </indexterm>
        <figure>
            <title>Managing log messages of TCP sources in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center" fileref="io2.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io2.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>The flow-control of syslog-ng introduces a control window to the source that tracks
            how many messages can syslog-ng accept from the source. Every message that syslog-ng
            reads from the source lowers the window size by one; every message that syslog-ng
            successfully sends from the output buffer increases the window size by one. If the
            window is full (that is, its size decreases to zero), syslog-ng stops reading messages from
            the source. The initial size of the control window is by default
            <parameter>1000</parameter>: the <parameter>log_fifo_size()</parameter> must be larger
            than this value in order for flow-control to have any effect. If a source accepts
            messages from multiple connections, all messages use the same control window.</para>
        <note>
            <para>Starting with &abbrev; version <phrase condition="pe">4.1</phrase><phrase condition="ose">3.3</phrase>, if the source can handle multiple connections (for example, <parameter>tcp()</parameter>), the size of the control window is divided by the value of the <parameter>max_connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
        </note>
        <para>When flow-control is used, every source has its own control window. As a worst-case
            situation, the output buffer of the destination must be set to accommodate all messages
            of every control window, that is, the <parameter>log_fifo_size()</parameter> of the
            destination must be greater than
                <parameter>number_of_sources</parameter>*<parameter>log_iw_size()</parameter>. This
            applies to every source that sends logs to the particular destination. Thus if two
            sources having several connections and heavy traffic send logs to the same destination,
            the control window of both sources must fit into the output buffer of the destination.
            Otherwise, syslog-ng does not activate the flow-control, and messages may be lost.</para>
        <para>The syslog-ng application handles outgoing messages the following way:</para>
        <figure>
            <title>Handling outgoing messages in &abbrev;</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60"
                        fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>output queue</primary>
                </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to
                    the target syslog-ng server. The syslog-ng application puts the outgoing
                    messages directly into the output queue, unless the output queue is full. The
                    output queue can hold 64 messages, this is a fixed value and cannot be
                modified.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>disk queue</primary>
                    <secondary>disk buffer</secondary>
                </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full and
                    disk-buffering is enabled, syslog-ng Premium Edition puts the outgoing messages into the disk
                    buffer of the destination.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>overflow queue</primary>
                    <secondary>output buffer</secondary>
                </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full and the disk
                    buffer is disabled or full, syslog-ng puts the outgoing messages into the
                    overflow queue of the destination. (The overflow queue is identical to the
                    output buffer used by other destinations.) The
                    <parameter>log_fifo_size()</parameter> parameter specifies the number of
                    messages stored in the overflow queue. For details on sizing the
                        <parameter>log_fifo_size()</parameter> parameter, see <xref
                        linkend="concepts_flow_control"/>.</para>
            </listitem>
        </itemizedlist>
        <para>There are two types of flow-control: Hard flow-control and soft flow-control.</para>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>soft</secondary>
                </indexterm>
                <para><emphasis>Soft flow-control:</emphasis> In case of soft flow-control there is no message lost if the destination can accept messages, but it is possible to lose messages if it cannot accept messages (for example non-writeable file destination, or the disk becomes full), and all buffers are full. Soft flow-control cannot be configured, it is automatically available for file and logstore destinations.</para>
                <example><para><synopsis>source s_file {file("/tmp/input_file.log");};
destination d_file {file("/tmp/output_file.log");};
destination d_tcp { tcp("127.0.0.1" port(2222) log_fifo_size(1000)); };
log{ source(s_file); destination(d_file); destination(d_tcp);};
</synopsis></para></example>
            <warning><para>Hazard of data loss! For destinations other than file and logstore, soft flow-control is not available. Thus, it is possible to lose log messages on those destinations. To avoid data loss on those destinations, use hard flow-control.</para></warning>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>hard</secondary>
                </indexterm>
                <para><emphasis>Hard flow-control:</emphasis> In case of hard flow-control there is no message lost. To use hard flow-control, enable the <parameter>flow_control</parameter> flag in the logpath. Hard flow-control is available for all destinations.</para>
                <example><para><synopsis>source s_file {file("/tmp/input_file.log");};
destination d_file {file("/tmp/output_file.log");};
destination d_tcp { tcp("127.0.0.1" port(2222) log_fifo_size(1000)); };
log{ source(s_file); destination(d_file); destination(d_tcp) flags(flow_control);};
</synopsis></para></example>
            </listitem>
        </itemizedlist>
        
        <section>
            <title>Flow-control and multiple destinations</title>
            <indexterm>
                <primary>flow-control</primary>
                <secondary>multiple destinations</secondary>
            </indexterm>
            <!-- FIXME ide az embedded logpaths and flowcontrolt -->
            <para>Using flow-control on a source has an important side-effect if the messages of the
                source are sent to multiple destinations. If flow-control is in use and one of the
                destinations cannot accept the messages, the other destinations do not receive any
                messages either, because syslog-ng stops reading the source. For example, if
                messages from a source are sent to a remote server and also stored locally in a
                file, and the network connection to the server becomes unavailable, neither the
                remote server nor the local file will receive any messages.</para>
            <note>
                <para>Creating separate log paths for the destinations that use the same
                    flow-controlled source does not avoid the problem.</para>
            </note>
        </section>
        <section id="configuring_flow_control">
            <title>Configuring flow-control</title>
            <indexterm>
                <primary>log paths</primary>
                <secondary>flow-control</secondary>
            </indexterm>
            <indexterm>
                <primary>flow-control</primary>
            </indexterm>
            <indexterm>
                <primary>preventing message loss</primary>
                <secondary>flow-control</secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary>
                    <parameter>log_fetch_limit()</parameter>
                </secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary>
                    <parameter>log_fifo_size()</parameter>
                </secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary>
                    <parameter>log_iw_size()</parameter>
                </secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary>
                    <parameter>max_connections()</parameter>
                </secondary>
            </indexterm>
            <indexterm>
                <primary>output buffer</primary>
            </indexterm>
            <para>For details on how flow-control works, see <xref linkend="concepts_flow_control"
                />. The summary of the main points is as follows:</para>
            <itemizedlist>
                <listitem>
                    <para>The syslog-ng application normally reads a maximum of
                            <parameter>log_fetch_limit()</parameter> number of messages from a
                        source.</para>
                </listitem>
                <listitem>
                    <para>From TCP and unix-stream sources, syslog-ng reads a maximum of
                            <parameter>log_fetch_limit()</parameter> from every connection of the
                        source. The number of connections to the source is set using the
                            <parameter>max_connections()</parameter> parameter.</para>
                </listitem>
                <listitem>
                    <para>Every destination has an output buffer
                        (<parameter>log_fifo_size()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>Flow-control uses a control window to determine if there is free space in
                        the output buffer for new messages. Every source has its own control window;
                            <parameter>log_iw_size()</parameter> parameter sets the size of the
                        control window.</para>
                </listitem>
                <listitem>
                    <para>When a source accepts multiple connections, the size of the control window is divided by the value of the <parameter>max_connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
                </listitem>
                <listitem>
                    <para>The output buffer must be larger than the control window of every source
                        that logs to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the control window is full, syslog-ng stops reading messages from the
                        source until some messages are successfully sent to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the output buffer becomes full, and <phrase condition="pe">neither disk-buffering nor flow-control is</phrase>
                         <phrase condition="ose">flow-control is not</phrase> used, messages may be lost.</para>
                </listitem>
            </itemizedlist>
            <note>
                <para>If you modify the <parameter>max_connections()</parameter> or the
                        <parameter>log_fetch_limit()</parameter> parameter, do not forget to adjust
                    the <parameter>log_iw_size()</parameter> and
                    <parameter>log_fifo_size()</parameter> parameters accordingly.</para>
            </note>
            <example>
                <title>Sizing parameters for flow-control</title>
                <indexterm>
                    <primary>log paths</primary>
                    <secondary>flow-control</secondary>
                </indexterm>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>example</secondary>
                </indexterm>
                <para>Suppose that syslog-ng has a source that must accept up to 300 parallel
                    connections. Such situation can arise when a network source receives connections
                    from many clients, or if many applications log to the same socket. Therefore,
                    set the <parameter>max_connections()</parameter> parameter of the source to
                        <parameter>300</parameter>. However, the
                    <parameter>log_fetch_limit()</parameter> (default value: 10) parameter applies
                    to every connection of the source individually, while the
                        <parameter>log_iw_size()</parameter> (default value: 1000) parameter applies
                    to the source. In a worst-case scenario, the destination does not accept any
                    messages, while all 300 connections send at least
                    <parameter>log_fetch_limit()</parameter> number of messages to the source during
                    every poll loop. Therefore, the control window must accommodate at least
                        <parameter>max_connections()</parameter>*<parameter>log_fetch_limit()</parameter>
                    messages to be able to read every incoming message of a poll loop. In the
                    current example this means that (<parameter>log_iw_size()</parameter> should be
                    greater than <parameter>300*10=3000</parameter>. If the control window is
                    smaller than this value, the control window might fill up with messages from the
                    first connections &mdash; causing syslog-ng to read only one message of the
                    last connections in every poll loop. </para>
                <para>The output buffer of the destination must accommodate at least
                        <parameter>log_iw_size()</parameter> messages, but use a greater value: in
                    the current example <parameter>3000*10=30000</parameter> messages. That way all
                    incoming messages of ten poll loops fit in the output buffer. If the output
                    buffer is full, syslog-ng does not read any messages from the source until some
                    messages are successfully sent to the destination.</para>
                <synopsis>source s_localhost { 
            tcp(ip(127.0.0.1) port(1999) max-connections(300)); };
destination d_tcp { 
            tcp("10.1.2.3" port(1999); localport(999)); log_fifo_size(30000); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
                <para>If other sources send messages to this destination, than the output buffer
                    must be further increased. For example, if a network host with maximum
                        <parameter>100</parameter> connections also logs into the destination, than
                    increase the <parameter>log_fifo_size()</parameter> by
                    <parameter>10000</parameter>.</para>
                <synopsis>source s_localhost { 
            tcp(ip(127.0.0.1) port(1999) max-connections(300)); };
source s_tcp { 
            tcp(ip(192.168.1.5) port(1999) max-connections(100)); };
destination d_tcp { 
            tcp("10.1.2.3" port(1999); localport(999)); log_fifo_size(40000); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
            </example>
        </section>
    </section>
    <section id="concepts_diskbuffer" condition="pe">
        <title>Using disk-based buffering</title>
        <indexterm significance="preferred">
            <primary>disk buffer</primary>
        </indexterm>
        <indexterm>
            <primary>disk-based buffering</primary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary>log_disk_fifo_size()</secondary>
        </indexterm>
        <!-- FIXME egysegesiteni kellene a flow control fejezettel -->
        <para>The Premium Edition of syslog-ng stores messages on the local hard disk if the central
            log server or the network connection to the server becomes unavailable. The syslog-ng
            application automatically sends the stored messages to the server when the connection is
            reestablished. The disk buffer is used as a queue: when the connection to the server is
            reestablished, syslog-ng sends the messages to the server in the order they were
            received.</para>
        <note>
            <para>Disk-based buffering can be used in conjunction with flow-control. For details, see <xref
                    linkend="concepts_flow_control"/>.</para>
        </note>
        <para>Disk buffers can be used with <parameter>tcp()</parameter>,
            <parameter>tcp6()</parameter>, <parameter>syslog()</parameter> (when using the
                <parameter>tcp</parameter> or <parameter>tls</parameter> transport methods), and
                <parameter>sql()</parameter> destinations. Every such destination uses a separate
            disk buffer (similarly to the output buffers controlled by
            <parameter>log_fifo_size()</parameter>). The hard disk space is not pre-allocated, so
            ensure that there is always enough free space to store the disk buffers even when the
            disk buffers are full.</para>
        <para>If syslog-ng is restarted (using the <command>/etc/init.d/syslog-ng restart</command>
            command), it automatically saves any unsent messages of the disk buffer and the output
            queue. After the restart, syslog-ng sends the saved messages to the server. In other
            words, the disk buffer is persistent. The disk buffer is also resistant to syslog-ng crashes.</para>
        <para>The syslog-ng application handles outgoing messages the following way:</para>
        <figure>
            <title>Handling outgoing messages in syslog-ng PE</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60"
                        fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>output queue</primary>
                </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to
                    the target syslog-ng server. The syslog-ng application puts the outgoing
                    messages directly into the output queue, unless the output queue is full. The
                    output queue can hold 64 messages, this is a fixed value and cannot be
                modified.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>disk queue</primary>
                    <see>disk buffer</see>
                </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full and
                    disk-buffering is enabled, syslog-ng puts the outgoing messages into the disk
                    buffer of the destination. The disk buffer is enabled if the
                        <parameter>log_disk_fifo_size()</parameter> parameter of the destination is
                    larger than <parameter>0</parameter>; the size of the disk buffer is specified
                    in bytes.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>overflow queue</primary>
                    <see>output buffer</see>
                </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full and the disk
                    buffer is disabled or full, syslog-ng puts the outgoing messages into the
                    overflow queue of the destination. (The overflow queue is identical to the
                    output buffer used by other destinations.) The
                    <parameter>log_fifo_size()</parameter> parameter specifies the number of
                    messages stored in the overflow queue. For details on sizing the
                        <parameter>log_fifo_size()</parameter> parameter, see also <xref
                        linkend="concepts_flow_control"/>.</para>
            </listitem>
        </itemizedlist>
        <note><para>Using disk buffer can significantly decrease performance.</para></note>
        <section id="configuring_diskbuffer">
	        <title>Enabling disk-based buffering</title>
	        <para>To enable disk-based buffering, use the <parameter>log_disk_fifo_size()</parameter>
	            parameter in the destination to set the size of the disk buffer in bytes. Note that this value applies to
	            every destination separately; every destination will have its own diskbuffer file, even
	            if the parameter is set as a global option. For details on how disk-based buffering
	            works, see <xref linkend="concepts_diskbuffer"/>. Disk buffers can be used with
	                <parameter>tcp()</parameter>, <parameter>tcp6()</parameter>,
	            <parameter>syslog()</parameter> (when using the <parameter>tcp</parameter> or
	                <parameter>tls</parameter> transport methods), and <parameter>sql()</parameter>
	            destinations. The number of messages that the disk buffer can store depends on the size
	            (length) of the actual messages. The maximum length of a message is limited by the
	                <parameter>log_msg_size()</parameter> parameter, which is 8192 bytes by default. </para>
	        <para id="diskbuffer_location"> The disk buffer is located under
	                <filename>/opt/syslog-ng/var/</filename> on every platform.</para>
	        <indexterm>
	            <primary>disk buffer</primary>
	            <secondary>location of</secondary>
	        </indexterm>
	        <example>
	                    <xi:include href="chapter-destinations.xml" xpointer="xpointer(//example[@id = 'example_diskbuffer']/node() )" xmlns:xi="http://www.w3.org/2001/XInclude"/>
	        </example>
	    </section>
    </section>
    <section id="concepts_failover" condition="pe">
        <title>Client-side failover</title>
        <indexterm>
                <primary>secondary servers</primary>
            </indexterm>
            <indexterm>
                <primary>failover servers</primary>
            </indexterm>
            <indexterm>
                <primary>fail-over servers</primary>
            </indexterm>
            <indexterm>
                <primary>tcp failover</primary>
            </indexterm>
            <indexterm>
                <primary>fail-over</primary>
            </indexterm>
            <indexterm>
                <primary>client-side failover</primary>
            </indexterm>
            <indexterm>
                <primary>FailoverSyslogServer</primary>
            </indexterm>
            <para>Starting with &product; 3.2., &abbrev; can detect if the remote server of a network destination becomes unaccessible, and start sending messages to a secondary server. Multiple failover servers can be configured; so if the secondary server becomes unaccessible as well, &abbrev; will switch to the third server in the list, and so on. If there are no more failover servers left, &abbrev; returns to the beginning of a list and attempts to connect to the primary server.</para>
            <para>When &abbrev; starts up, it will always try to connect to the primary server first, but once it fails over to a secondary server, it will not automatically attempt to return to the primary server even if it becomes available. However, if the configuration of &abbrev; is reloaded, it will attempt to connect the primary server.</para>
            <para>If &abbrev; uses TLS-encryption to communicate with the remote server, &abbrev; checks the certificate of the failover server as well. The certificates of the failover servers should match their domain names or IP addresses &mdash; for details, see <xref linkend="tls_serverauth"/>. Note that when mutual authentication is used, the &abbrev; client sends the same certificate to every server.</para>
            <para>The primary server and the failover servers must be accessible with the same communication method: it is not possible to use different destination drivers or options for the different servers.</para>
            <note>
                <para>Client-side failover works only for TCP-based connections, that is, the <parameter>tcp()</parameter> (including TLS-encrypted connections) and the <parameter>syslog()</parameter> destination driver (excluding UDP transport).</para>
                <para>Client-side failover is not supported in the <parameter>sql()</parameter> driver, even though it may use a TCP connection to access a remote database.</para>
            </note>
            <para>For details on configuring failover servers, see <xref linkend="example-failover-server-tcp"/> and <xref linkend="example-failover-server-syslog"/>.</para>
    </section>
    <section id="filters">
        <title>Filters</title>
        <indexterm significance="preferred">
            <primary>filters</primary>
        </indexterm>
        <indexterm significance="preferred">
            <primary>regular expressions</primary>
        </indexterm>
        <para>The following sections describe how to select and filter log messages.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="configuring_filters"/> describes how to configure and use
                    filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-boolean"/> shows how to create complex filters using boolean operators.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-comparing"/> explains how to evaluate macros in filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="regular_expressions"/> provides tips on using regular
                    expressions.</para>
            </listitem>
            <listitem>
                <para><xref linkend="tagging_messages"/> explains how to tag messages and how to
                    filter on the tags.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference_filters"/> is a detailed description of the filter functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section id="configuring_filters">
            <title>Using filters</title>
            <para>Filters perform log routing within syslog-ng: a message passes the filter if the
                filter expression is true for the particular message. If a log statement includes
                filters, the messages are sent to the destinations only if they pass all filters of
                the log path. For example, a filter can select only the messages originating from a
                particular host. Complex filters can be created using filter functions and logical
                boolean expressions.</para>
            <para>To define a filter, add a filter statement to the syslog-ng configuration file
                using the following syntax:</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>defining</secondary>
            </indexterm>
            <synopsis>filter &lt;identifier&gt; { &lt;filter_type&gt;("&lt;filter_expression&gt;"); };</synopsis>
            <example>
                <title>A simple filter statement</title>
                <para>The following filter statement selects the messages that contain the word <parameter>deny</parameter> and come from the host <parameter>example</parameter>.</para>
                <synopsis>filter demo_filter { host("example"); };</synopsis>
                <para>For the filter to have effect, include it in a log statement:</para>
                <synopsis>log demo_filteredlog {
        source(s1);
        filter(demo_filter);
        destination(d1);};</synopsis>
            </example>
        </section>
        <section id="filters-boolean">
            <title>Combining filters with boolean operators</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>boolean operators</secondary>
            </indexterm>
            <indexterm>
                <primary>filters</primary>
                <secondary>AND, OR, NOT</secondary>
            </indexterm>
            <indexterm>
                <primary>boolean operators</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>AND</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>OR</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>NOT</primary>
            </indexterm>
            <para>When a log statement includes multiple filter statements, syslog-ng sends a
                message to the destination only if all filters are true for the message. In other
                words, the filters are connected with the logical <parameter>AND</parameter>
                operator. In the following example, no message arrives to the destination, because
                the filters are exclusive (the hostname of a client cannot be
                <parameter>example1</parameter> and <parameter>example2</parameter> at the same
                time):</para>
                <synopsis>filter demo_filter1 { host("example1"); };
filter demo_filter2 { host("example2"); };
log demo_filteredlog {
    source(s1); source(s2); 
    filter(demo_filter1); filter(demo_filter2);
    destination(d1); destination(d2); };</synopsis>
            <para>To select the messages that come from either host
                <parameter>example1</parameter> or <parameter>example2</parameter>, use a single
                filter expression:</para>
            <synopsis>filter demo_filter { host("example1") or host("example2"); };
log demo_filteredlog {
    source(s1); source(s2); 
    filter(demo_filter);
    destination(d1); destination(d2); };</synopsis>
            <para>Use the <parameter>not</parameter> operator to invert filters, for example, to
                select the messages that were not sent by host <parameter>example1</parameter>: </para>
            <synopsis>filter demo_filter { not host("example1"); };</synopsis>
            <para>However, to select the messages that were not sent by host
                <parameter>example1</parameter> or <parameter>example2</parameter>, you have to use
                the <parameter>and</parameter> operator (that's how boolean logic works):</para>
            <synopsis>filter demo_filter { not host("example1") and not host("example2"); };</synopsis>
            <para>Alternatively, you can use parentheses to avoid this confusion:</para>
            <synopsis>filter demo_filter { not (host("example1") or host("example2")); };</synopsis>
            <para>For a complete description on filter functions, see <xref
                    linkend="reference_filters"/>. </para>
            <para>The following filter statement selects the messages that contain the word <parameter>deny</parameter> and come from the host <parameter>example</parameter>.</para>
            <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")); };</synopsis>
            <para>The <parameter>value()</parameter> parameter of the <parameter>match</parameter> function limits the scope of the function to the text part of the message (that is, the part returned by the <parameter>$MESSAGE</parameter> macro). For details on using the <parameter>match()</parameter> filter function, see <xref linkend="reference-filters-match"/>.</para>
            <tip>
                <para>Filters are often used together with log path flags. For details, see <xref linkend="reference_logflags"/>.</para>
            </tip>
        </section>
        <section id="filters-comparing">
            <title>Comparing macro values in filters</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>comparing values</secondary>
            </indexterm>
            <indexterm type="parameter">
                <primary>ge</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>gt</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>eq</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>ne</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>le</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>lt</primary>
            </indexterm>
            <indexterm>
                <primary>string comparison</primary>
            </indexterm>
            <indexterm>
                <primary>value comparison</primary>
            </indexterm>
            <indexterm>
                <primary>comparing values</primary>
            </indexterm>
            <indexterm>
                <primary>filters</primary>
                <secondary>comparing values</secondary>
            </indexterm>
            <para>Starting with &abbrev; version <phrase condition="ose">3.2</phrase><phrase condition="pe">4.1</phrase>, it is also possible to compare macro values and templates as numerical and string values. String comparison is alphabetical: it determines if a string is alphabetically greater or equal to another string. Use the following syntax to compare macro values or templates. For details on macros and templates, see <xref linkend="customizing-message-format"/>.</para>
            <synopsis>filter &lt;filter-id&gt; 
        {"&lt;macro-or-template&gt;" operator "&lt;value-or-macro-or-template&gt;"};</synopsis>
            <example id="example-comparison">
                <title>Comparing macro values in filters</title>
                <para>The following expression selects log messages containing a PID (that is, <parameter>$PID</parameter> macro is not empty):</para>
                <synopsis>filter f_pid {"$PID" !=""};</synopsis>
                <para>The following expression accomplishes the same, but uses a template as the left argument of the operator and compares the values as strings:</para>
                <synopsis>filter f_pid {"$HOST$PID" eq "$HOST"};</synopsis>
                <para>The following example selects messages with priority level 4 or higher.</para>
                <synopsis>filter f_level {"$LEVEL_NUM" &gt; "5"};</synopsis>
            </example>
            <para>Note that:</para>
            <itemizedlist>
                <listitem>
                    <para>The macro or template must be enclosed in double-quotes.</para>
                </listitem>
                <listitem>
                    <para>The <parameter>$</parameter> character must be used before macros.</para>
                </listitem>
                <listitem>
                    <para>Using comparator operators can be equivalent to using filter functions, but is somewhat slower. For example, using <parameter>"$HOST" eq "myhost"</parameter> is equivalent to using <parameter>host("myhost" type(string))</parameter>.</para>
                </listitem>
                <listitem>
                    <para>You can use any macro in the expression, including user-defined macros from parsers and results of pattern database classifications.</para>
                </listitem>
                <listitem>
                    <para>The results of filter functions are boolean values, so they cannot be compared to other values.</para>
                </listitem>
                <listitem>
                    <para>You can use boolean operators to combine comparison expressions.</para>
                    <!-- FIXME tenyleg? ha igen, peldat is!-->
                </listitem>
            </itemizedlist>
            <para>The following operators are available:</para>
            <table>
                <title>Numerical and string comparison operators</title>
                <?dbfo keep-together="auto" ?>
                <tgroup cols="3">
                    <thead>
                        <row>
                            <entry>Numerical operator</entry>
                            <entry>String operator</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>==</entry>
                            <entry>eq</entry>
                            <entry>Equals</entry>
                        </row>
                        <row>
                            <entry>!=</entry>
                            <entry>ne</entry>
                            <entry>Not equal to</entry>
                        </row>
                        <row>
                            <entry>&gt;</entry>
                            <entry>gt</entry>
                            <entry>Greater than</entry>
                        </row>
                        <row>
                            <entry>&lt;</entry>
                            <entry>lt</entry>
                            <entry>Less than</entry>
                        </row>
                        <row>
                            <entry>&gt;=</entry>
                            <entry>ge</entry>
                            <entry>Greater than or equal</entry>
                        </row>
                        <row>
                            <entry>=&lt;</entry>
                            <entry>le</entry>
                            <entry>Less than or equal</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section id="regular_expressions">
            <title>Using wildcards, special characters, and regular expressions in filters</title>
            <para>
                <indexterm>
                <primary>regular expressions</primary>
                <secondary>posix</secondary>
                </indexterm>
                The <parameter>host()</parameter>, <parameter>match()</parameter>, and
                    <parameter>program()</parameter> filter functions accept regular expressions as
                parameters. The exact type of the regular expression to use can be specified with the
                    <parameter>type()</parameter> option. By default, &abbrev; uses POSIX regular expressions.</para>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>wildcards</secondary>
                </indexterm>
                <para>In regular expressions, the asterisk (<parameter>*</parameter>) character
                    means 0, 1 or any number of the previous expression. For example, in the
                        <parameter>f*ilter</parameter> expression the asterisk means 0 or more f
                    letters. This expression matches for the following strings:
                    <parameter>ilter</parameter>, <parameter>filter</parameter>,
                    <parameter>ffilter</parameter>, and so on. To achieve the wildcard functionality
                    commonly represented by the asterisk character in other applications, use
                        <parameter>.*</parameter> in your expressions, for example
                    <parameter>f.*ilter</parameter>.</para>
                <para>Alternatively, if you do not need regular expressions, only wildcards, use <parameter>type(glob)</parameter> in your filter:</para>
                <example id="example-wildcard-filter">
                    <title>Filtering with widcards</title>
                    <para>The following filter matches on hostnames starting with the <parameter>myhost</parameter> string, for example, on <parameter>myhost-1</parameter>, <parameter>myhost-2</parameter>, and so on.</para>
                    <synopsis>filter f_wildcard {host("myhost*" type(glob));};</synopsis>
                </example>
                <para>For details on using regular expressions in &abbrev;, see <xref linkend="regular-expressions"/>.</para>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>control characters</secondary>
                </indexterm>
                <para>To filter for special control characters like the carriage return (CR), use the <parameter>\r</parameter> escape prefix in &abbrev; version 3.0 and 3.1. In &abbrev; 3.2 and later, you can also use the <parameter>\x</parameter> escape prefix and the ASCII code of the character. For example, to filter on carriage returns, use the following filter:</para>
                <synopsis>filter f_carriage_return {match("\x0d" value ("MESSAGE"));};</synopsis>
        </section>
        <section id="tagging_messages">
            <title>Tagging messages</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>tags</secondary>
            </indexterm>
            <indexterm>
                <primary>tagging messages</primary>
            </indexterm>
            <indexterm>
                <primary>tags</primary>
            </indexterm>
            <para>Starting with syslog-ng 3.1, it is also possible to label the messages with custom
                tags. Tags are simple labels, identified by their names, which must be unique.
                Currently syslog-ng can tag a message at two different places:</para>
            <itemizedlist>
                <listitem>
                    <para>at the source when the message is received; and</para>
                </listitem>
                <listitem>
                    <para>when the message matches a pattern in the pattern database. For details on
                        using the pattern database, see <xref
                            linkend="configuring_pattern_databases"/>, for details on creating tags
                        in the pattern database, see <xref linkend="reference_patterndb_schemes"
                    />.</para>
                </listitem>
            </itemizedlist>
            <para>When syslog-ng receives a message, it automatically adds the
                    <parameter>.source.&lt;id_of_the_source_statement&gt;</parameter> tag to
                the message. Use the <parameter>tags()</parameter> option of the source to add
                custom tags, and the <parameter>tags()</parameter> option of the filters to select
                only specific messages.</para>
            <note>
                <itemizedlist>
                    <listitem>
                        <para>Tagging messages and also filtering on the tags is very fast, much faster then other types of filters.</para>
                    </listitem>
                    <listitem>
                        <para>Tags are available locally, that is, if you add tags to a message on the client, these tags will not be available on the server.</para>
                    </listitem>
                    <listitem>
                        <para>To include the tags in the message, use the <parameter>$TAGS</parameter> macro in a template. Alternatively, if you are using the IETF-syslog message format, you can include the <parameter>$TAGS</parameter> macro in the <parameter>.SDATA.meta</parameter> part of the message. Note that the <parameter>$TAGS</parameter> macro is available only in &abbrev; 3.1.1 and later.</para>
                    </listitem>
                </itemizedlist>
            </note>
            <para>For an example on tagging, see <xref linkend="example_tags_filtering"/>.</para>
        </section>
        <section id="reference_filters">
            <title>Filter functions</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>reference</secondary>
            </indexterm>
            <para>The following functions may be used in the filter statement, as described in <xref linkend="filters"/>.</para>
            <table id="table_filter_functions">
                <title>Filter functions available in &abbrev;</title>
                <indexterm>
                    <primary>filter functions</primary>
                    <secondary>list of</secondary>
                </indexterm>
                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Name</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <link linkend="filter-facility">facility()</link>
                            </entry>
                            <entry>Filter messages based on the sending facility.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-filter">filter()</link>
                            </entry>
                            <entry>Call another filter function.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-host">host()</link>
                            </entry>
                            <entry>Filter messages based on the sending host.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-priority">level() or priority()</link>
                            </entry>
                            <entry>Filter messages based on their priority.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="reference-filters-match">match()</link>
                            </entry>
                            <entry>Use a regular expression to filter messages based on a specified header or content field.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-message">message()</link>
                            </entry>
                            <entry>Use a regular expression to filter messages based their content.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-netmask">netmask()</link>
                            </entry>
                            <entry>Filter messages based on the IP address of the sending host.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-program">program()</link>
                            </entry>
                            <entry>Filter messages based on the sending application.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-source">source()</link>
                            </entry>
                            <entry>Select messages of the specified &abbrev; source statement.</entry>
                        </row>
                        <row>
                            <entry>
                                <link linkend="filter-tags">tags()</link>
                            </entry>
                            <entry>Select messages having the specified tag.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <simplesect id="filter-facility">
                <title>facility()</title>
                    <indexterm type="parameter">
                        <primary>facility()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>facility(facility[,facility])</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Match messages having one of the listed facility code. An alternate
                                syntax permits the use an arbitrary facility codes.</para>
                <indexterm>
                <primary>filters</primary>
                <secondary>facilities, </secondary>
            </indexterm>
            <para>The <parameter>facility()</parameter> filter accepts both the name and the numerical
                code of the facility or the importance level.</para>
            <para>Messages sent by a range of facilities can also be selected. Note that
                this is only possible when using the name of the facilities. It is not possible to
                select ranges the numerical codes of the facilities.</para>
            <synopsis>facility(local0..local5)</synopsis>
            <para>The syslog-ng application recognizes the
                following facilities: (Note that some of these facilities are available only on specific
                platforms.)</para>
            <!-- FIXME authpriv -->
            <table>
                <title>syslog Message Facilities recognized by the facility() filter</title>
                <?dbfo keep-together="auto" ?>
                <indexterm>
                    <primary>facilities</primary>
                </indexterm>
                <indexterm>
                    <primary>message facilities</primary>
                </indexterm>
                <tgroup cols="3">
                    <thead>
                        <row>
                            <entry>Numerical Code</entry>
                            <entry>Facility name</entry>
                            <entry>Facility</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>0</entry>
                            <entry>kern</entry>
                            <entry>kernel messages</entry>
                        </row>
                        <row>
                            <entry>1</entry>
                            <entry>user</entry>
                            <entry>user-level messages</entry>
                        </row>
                        <row>
                            <entry>2</entry>
                            <entry>mail</entry>
                            <entry>mail system</entry>
                        </row>
                        <row>
                            <entry>3</entry>
                            <entry>daemon</entry>
                            <entry>system daemons</entry>
                        </row>
                        <row>
                            <entry>4</entry>
                            <entry>auth</entry>
                            <entry>security/authorization messages</entry>
                        </row>
                        <row>
                            <entry>5</entry>
                            <entry>syslog</entry>
                            <entry>messages generated internally by syslogd</entry>
                        </row>
                        <row>
                            <entry>6</entry>
                            <entry>lpr</entry>
                            <entry>line printer subsystem</entry>
                        </row>
                        <row>
                            <entry>7</entry>
                            <entry>news</entry>
                            <entry>network news subsystem</entry>
                        </row>
                        <row>
                            <entry>8</entry>
                            <entry>uucp</entry>
                            <entry>UUCP subsystem</entry>
                        </row>
                        <row>
                            <entry>9</entry>
                            <entry>cron</entry>
                            <entry>clock daemon</entry>
                        </row>
                        <row>
                            <entry>10</entry>
                            <entry>auth</entry>
                            <entry>security/authorization messages</entry>
                        </row>
                        <row>
                            <entry>11</entry>
                            <entry>ftp</entry>
                            <entry>FTP daemon</entry>
                        </row>
                        <row>
                            <entry>12</entry>
                            <entry><!-- FIXME --></entry>
                            <entry>NTP subsystem</entry>
                        </row>
                        <row>
                            <entry>13</entry>
                            <entry><!-- FIXME --></entry>
                            <entry>log audit</entry>
                        </row>
                        <row>
                            <entry>14</entry>
                            <entry><!-- FIXME --></entry>
                            <entry>log alert</entry>
                        </row>
                        <row>
                            <entry>15</entry>
                            <entry>cron</entry>
                            <entry>clock daemon</entry>
                        </row>
                        <row>
                            <entry>16-23</entry>
                            <entry>local0..local7</entry>
                            <entry>locally used facilities (local0-local7)</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            </simplesect>
            <simplesect>
                <title>facility()</title>
                    <indexterm type="parameter">
                        <primary>facility()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>facility(&lt;numeric facility code&gt;)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> An alternate syntax for <parameter>facility</parameter> permitting
                                the use of an arbitrary facility code. Facility codes 0-23 are
                                predefined and can be referenced by their usual name. Facility codes
                                above 24 are not defined but can be used by this alternate syntax.</para>
            </simplesect>
            <simplesect id="filter-filter">
                <title>filter()</title>
                    <indexterm type="parameter">
                        <primary>filter()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>filter(filtername)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Call another filter rule and evaluate its value.</para>
            </simplesect>
            <simplesect id="filter-host">
                <title>host()</title>
                    <indexterm type="parameter">
                        <primary>host()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>host(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Match messages by using a regular expression against the hostname
                                field of log messages.</para>
            </simplesect>
            <simplesect id="filter-priority">
                <title>level() or priority()</title>
                    <indexterm type="parameter">
                        <primary>level() or priority()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>level(pri[,pri1..pri2[,pri3]])</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Match messages based on priority.</para>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>priorities</secondary>
                </indexterm>
                <para>The <parameter>level()</parameter> filter accepts the following levels:
                        <parameter>emerg</parameter>, <parameter>alert</parameter>,
                    <parameter>crit</parameter>, <parameter>err</parameter>, <parameter>warning</parameter>,
                        <parameter>notice</parameter>, <parameter>info</parameter>,
                    <parameter>debug</parameter>. </para>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>facility and priority (level) ranges</secondary>
                </indexterm>
                <para>The <parameter>level()</parameter> filter can select messages
                    corresponding to a single importance level, or a level-range. To select messages of
                    a specific level, use the name of the level as a filter parameter, for example use the
                    following to select warning messages:</para>
                <synopsis>level(warning)</synopsis>
                <para>To select a range of levels, include the beginning and the ending level in the
                    filter, separated with two dots (<parameter>..</parameter>). For example, to select
                    every message of error or higher level, use the following filter:</para>
                <synopsis>level(err..emerg)</synopsis>
            </simplesect>
            <simplesect id="reference-filters-match">
                <title>match()</title>
                <indexterm type="parameter">
                    <primary>match()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>match(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Match a regular expression to the headers and the message itself
                                (that is, the values returned by the <parameter>MSGHDR</parameter> and
                                    <parameter>MSG</parameter> macros). Note that in syslog-ng version
                                2.1 and earlier, the <parameter>match()</parameter> filter was applied
                                only to the text of the message, excluding the headers. This
                                functionality has been moved to the <parameter>message()</parameter>
                                filter.</para>
                <indexterm type="parameter">
                    <primary>value()</primary>
                </indexterm>
                <para>To limit the scope of the match to a specific part of the message (identified with a macro), use the <parameter>match(regexp value("MACRO"))</parameter> syntax. Do not include the $ sign in the parameter of the <parameter>value()</parameter> option.</para>
                <para>The <parameter>value()</parameter> parameter accepts both built-in macros and user-defined ones created with a parser or using a pattern database. For details on macros and parsers, see <xref linkend="configuring_macros"/>, <xref linkend="configuring_parsers"/>, and <xref linkend="patterndb-filters"/>.</para>
            </simplesect>
            <simplesect id="filter-message">
                <title>message()</title>
                    <indexterm type="parameter">
                        <primary>message()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>message(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Match a regular expression to the text of the log message, excluding
                                the headers (that is, the value returned by the <parameter>MSG</parameter>
                                macros). Note that in syslog-ng version 2.1 and earlier, this
                                functionality was performed by the <parameter>match()</parameter>
                                filter.</para>
            </simplesect>
            <simplesect id="filter-netmask">
                <title>netmask()</title>
                    <indexterm type="parameter">
                        <primary>netmask()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>netmask(ip/mask)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Select only messages sent by a host whose IP address belongs to the
                                specified IP subnet. Note that this filter checks the IP address of the
                                last-hop relay (the host that actually sent the message to syslog-ng),
                                not the contents of the <parameter>HOST</parameter> field of the
                                message.</para>
            </simplesect>
            <simplesect id="filter-program">
                <title>program()</title>
                    <indexterm type="parameter">
                        <primary>program()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>program(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Match messages by using a regular expression against the program name
                                field of log messages.</para>
            </simplesect>
            <simplesect id="filter-source">
                <title>source()</title>
                    <indexterm type="parameter">
                        <primary>source()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>source id</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Select messages of a source statement. This filter can be used in
                                embedded log statements if the parent statement contains multiple source
                                groups &mdash; only messages originating from the selected source
                                group are sent to the destination of the embedded log statement.</para>
            </simplesect>
            <simplesect id="filter-tags">
                <title>tags()</title>
                    <indexterm type="parameter">
                        <primary>tags()</primary>
                    </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                                <entry>tag</entry>
                            </row>
                        </tbody>
                    </tgroup>  
                </informaltable>
                <para><guilabel>Description:</guilabel> Select messages labeled with the specified tag. Every message
                                automatically has the tag of its source in <parameter>.source.&lt;id_of_the_source_statement&gt;</parameter> format. This option is available only in syslog-ng 3.1 and later.</para>
                <example id="example_tags_filtering">
                    <title>Adding tags and filtering messages with tags</title>
                    <synopsis>source s_tcp {
    tcp(ip(192.168.1.1) port(1514) tags("tcp", "router"));
    };</synopsis>
                    <para>Use the <parameter>tags()</parameter> option of the filters to select only
                        specific messages:</para>
                    <synopsis>filter f_tcp {
       tags(".source.s_tcp");
    };

    filter f_router {
       tags("router");
    };</synopsis>
                </example>
                <xi:include href="chapter-patterndb.xml" xpointer="xpointer(//note[@id = 'example-tag-class']/node() )" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
        </section>
    </section>
    <section id="example_dropping_messages">
        <title>Dropping messages</title>
        <indexterm>
            <primary>skipping messages</primary>
        </indexterm>
        <indexterm>
            <primary>dropping messages</primary>
        </indexterm>
        <indexterm>
            <primary>discarding messages</primary>
        </indexterm>
        <para>To skip the processing of a message without sending it to a destination, create a log
            statement with the appropriate filters, but do not include any destination in the
            statement, and use the <parameter>final</parameter> flag. </para>
        <example>
            <title>Skipping messages</title>
            <para>The following log statement drops all <parameter>debug</parameter> level messages
                without any further processing.</para>
            <synopsis>filter demo_debugfilter { level(debug); };
log { source(s_all); filter(demo_debugfilter); flags(final); };</synopsis>
        </example>
    </section>
    
</chapter>
