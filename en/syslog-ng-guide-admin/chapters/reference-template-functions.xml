<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section
 [  <!ENTITY % entities SYSTEM "../../common/syslog-ng-entities.ent">
 %entities;]>
<section xml:id="reference-template-functions" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Template functions of &abbrev;</title>
    <para>The following template functions are available in &abbrev;.</para>
    <simplesect xml:id="template-function-echo">
        <title>echo</title>
        <indexterm>
            <primary>echo</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis>
            <synopsis>$(echo argument)</synopsis></para>
        <para><emphasis role="bold">Description:</emphasis> Returns the value of its argument. Using <userinput>$(echo ${HOST})</userinput> is equivalent to <parameter>${HOST}</parameter>.</para>
    </simplesect>
    <simplesect xml:id="template-function-format-json">
        <title>format-json</title>
            <indexterm>
                <primary>format-json</primary>
            </indexterm>
        <indexterm>
            <primary>JSON</primary>
        </indexterm>
        <indexterm>
            <primary>JavaScript Object Notation</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis> <synopsis>$(format-json parameters)</synopsis></para>
        <para><emphasis role="bold">Description:</emphasis> The <parameter>format-json</parameter> template function receives value-pairs as parameters and converts them into JavaScript Object Notation (JSON) format. Including the template function in a message template allows you to store selected information about a log message (that is, its content, macros, or other metadata) in JSON format.</para>
        <para>For details on selecting value-pairs in &abbrev; and for possibilities to specify which information to convert to JSON format, see <xref linkend="concepts-value-pairs"/>. Note that the syntax of <parameter>format-json</parameter> is different from the syntax of <parameter>value-pairs()</parameter>: <parameter>format-json</parameter> uses a syntax similar to command lines.</para>

        <xi:include href="../../common/wnt/note-typehinting.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>

        <example>
            <title>Using the format-json template function</title>
            <para>The following example selects every available information about the log message, except for the date-related macros (<userinput>R_*</userinput> and <userinput>S_*</userinput>), selects the <userinput>.SDATA.meta.sequenceId</userinput> macro, and defines a new value-pair called <userinput>MSGHDR</userinput> that contains the program name and PID of the application that sent the log message (since you will use the template-function in a template, you must escape the double-quotes).</para>
            <synopsis>$(format-json --scope syslog,all_macros,selected_macros \
  --exclude R_* --exclude S_* --key .SDATA.meta.sequenceId \
  --pair MSGHDR=\"$PROGRAM[$PID]: \")</synopsis>
                    <para>The following example shows how to use this template function to store log messages in JSON format:</para>
                    <synopsis>destination d_json {
  file("/var/log/messages.json" template("$(format_json --scope selected_macros --scope nv_pairs)\n"));
};</synopsis>
        </example>
        <note>
            <para>In case of syslog-ng macros starting with a dot (for example "<userinput>.SDATA.meta.sequenceID</userinput>") an empty key name is added at the top level of the JSON structure. You can work around this by adding <userinput>--shift 1</userinput> as a parameter to the template function. For example in case of "<userinput>.SDATA.meta.sequenceID</userinput>", an empty key name is added at the top level of the JSON structure:</para>
            <synopsis>{"":
    {"SDATA" :
        {"meta" :
            {"sequenceID": "123"}
        }
    }
}</synopsis>
        </note>
    </simplesect>
    <simplesect xml:id="template-function-format-welf" condition="pe">
        <title>format-welf</title>
        <indexterm>
            <primary>format-welf()</primary>
        </indexterm>
        <indexterm>
            <primary>WELF</primary>
        </indexterm>
        <indexterm>
            <primary>WebTrends Enhanced Log file Format</primary>
        </indexterm>
        <para>This template function converts value-pairs into the WebTrends Enhanced Log file Format (WELF). The WELF format is a comma-separated list of <userinput>name=value</userinput> elements. Note that the order of the elements is random. If the value contains whitespace, it is enclosed in double-quotes, for example, <userinput>name="value"</userinput>. For details on the WELF format, see <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://www.m86security.com/kb/article.aspx?id=10899">http://www.m86security.com/kb/article.aspx?id=10899</link>.</para>
        <para>To select which value-pairs to convert, use the command-line syntax of the <parameter>value-pairs()</parameter> option. For details on selecting value-pairs, see <xref linkend="options-value-pairs"/>.</para>
        <example>
            <title>Using the <parameter>format-welf()</parameter> template function</title>
             <para>The following example selects every available information about the log message, except for the date-related macros (<userinput>R_*</userinput> and <userinput>S_*</userinput>), selects the <userinput>.SDATA.meta.sequenceId</userinput> macro, and defines a new value-pair called <userinput>MSGHDR</userinput> that contains the program name and PID of the application that sent the log message (since you will use the template-function in a template, you must escape the double-quotes).</para>
            <synopsis>$(format-welf --scope syslog,all_macros,selected_macros \
  --exclude R_* --exclude S_* --key .SDATA.meta.sequenceId \
  --pair MSGHDR=\"$PROGRAM[$PID]: \")</synopsis>
                    <para>The following example shows how to use this template function to store log messages in WELF format:</para>
                    <synopsis>destination d_welf {
  file("/var/log/messages.welf" template("$(format_welf --scope selected_macros --scope nv_pairs)\n"));
};</synopsis>
        </example>
    </simplesect>
    <simplesect xml:id="template-function-grep">
        <title>grep</title>
        <indexterm>
            <primary>grep</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis>
            <synopsis>$(grep condition value-to-select)</synopsis><!-- FIXME pontositani --></para>
        <para><emphasis role="bold">Description:</emphasis> The <parameter>grep</parameter> template function is useful when using a pattern database to correlate related log messages. The <parameter>grep</parameter> template function can be used to filter the messages of the same context when the index of the particular message is not known.</para>
        <example>
            <title>Using the grep template function</title>
            <para>The following example selects the message of the context that has a <userinput>username</userinput> name-value pair with the <userinput>root</userinput> value, and returns the value of the <userinput>auth_method</userinput> name-value pair.</para>
            <synopsis>$(grep ("${username}" == "root") ${auth_method})</synopsis>
        </example>
        <para>It is possible to specify multiple name-value pairs as parameters, separated with commas. If multiple messages match the condition of <parameter>grep</parameter>, these will be returned also separated by commas. This can be used for example to collect the e-mail recipients from postfix messages.</para>
        <!-- FIXME konkret peldat! -->
    </simplesect>
    <simplesect xml:id="template-function-hash">
        <title>hash</title>
        <indexterm type="parameter">
            <primary>tfhash</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>$(hash)</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>$(md5), $(md4)</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>$(sha1), $(sha256), $(sha512)</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>tfhash</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis> <synopsis>$(&lt;method&gt; [opts] $arg1 $arg2 $arg3...)</synopsis></para>
        <para><emphasis role="bold">Options:</emphasis> <synopsis>--length N, -l N</synopsis> Truncate the hash to the first N characters.</para>
        <para><emphasis role="bold">Description:</emphasis> <userinput>&lt;method&gt;</userinput> can be one of md5, md4, sha1, sha256, sha512 and "hash", which is equivalent to md5. Macros are expected as arguments, and they are concatenated without the use of additional characters.</para>
        <para>This template function can be used for anonymizing sensitive parts of the log message (for example username) that were parsed out using PatternDB before storing or forwarding the message. This way, the ability of correlating messages along this value is retained.</para>
        <para>Also, using this template, quasi-unique IDs can be generated for data, using the <parameter>--length</parameter> option. This way, IDs will be shorter than a regular hash, but there is a very small possibility of them not being as unique as a non-truncated hash.</para>
        <note condition="ose">
            <para>These template functions are available only if <phrase condition="ose">&abbrev; has been compiled with the <parameter>--enable-ssl</parameter> compile option and </phrase>the <filename>tfhash</filename> module has been loaded. By default, &abbrev; loads every available module.</para>
            <!-- FIXME link a modulokrol szolo leirasra-->
        </note>
        <example xml:id="template-function-hash-example">
            <title>Using the $(hash) template function</title>
            <para>The following example calculates the SHA1 hash of the hostname of the message:</para>
            <synopsis>$(sha1 $HOST)</synopsis>
            <para>The following example calculates the SHA256 hash of the hostname and the program of the message:</para>
            <synopsis>$(sha1 $HOST $PROGRAM)</synopsis>
            <para>To use shorter hashes, set the <parameter>--length</parameter>:</para>
            <synopsis>$(sha1 --length 6 $HOST)</synopsis>
            <para>To replace the hostname with its hash, use a rewrite rule:</para>
            <synopsis>rewrite r_rewrite_hostname{set("$(sha1 $HOST)", value("HOST"));};</synopsis>
        </example>
    </simplesect>
    <simplesect xml:id="template-function-if">
        <title>if</title>
        <indexterm>
            <primary>if</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis>
            <synopsis>$(if (&lt;condition&gt;) &lt;true template&gt; &lt;false template&gt;)</synopsis></para>
        <para><emphasis role="bold">Description:</emphasis> Returns the value of the <userinput>&lt;true template&gt;</userinput> parameter if the <userinput>&lt;condition&gt;</userinput> is true. If the <userinput>&lt;condition&gt;</userinput> is false, the value of <userinput>&lt;false template&gt;</userinput> is returned.</para>
        <example>
            <title>Using pattern databases and the if template function</title>
            <para>The following example returns <userinput>violation</userinput> if the <userinput>username</userinput> name-value pair of a message processed with pattern database is <userinput>root</userinput>, and <userinput>system</userinput> otherwise.</para>
            <synopsis>$(if ('${username}' == 'root') 'violation' 'system')</synopsis>
            <para>This can be used to set the class of a message in pattern database rules based on the condition.</para>
            <synopsis>&lt;value name="username"&gt;$(if ("${username}" == "root") "violation" "system")&lt;/value&gt;</synopsis>
            <indexterm>
                <primary>template functions</primary>
                <secondary>embedding</secondary>
            </indexterm>
            <para>Since template functions can be embedded into each other, it is possible to use another template function as the template of the first one. For example, the following expression returns <userinput>root</userinput> if the username is <userinput>root</userinput>, <userinput>admin</userinput> if the username is <userinput>joe</userinput>, and <userinput>normal user</userinput> otherwise.</para>
            <synopsis>&lt;value name="username"&gt;
    $(if ("${username}" == "root")
        "root"
        $(if ("${username}" == "joe") "admin" "normal user")
        "normal user")&lt;/value&gt;</synopsis>
        </example>
    </simplesect>
    <simplesect xml:id="template-function-indent-multi-line">
        <title>indent-multi-line</title>
        <indexterm>
            <primary>indent-multi-line</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis>
            <synopsis>$(indent-multi-line parameter)</synopsis></para>
        <para><emphasis role="bold">Description:</emphasis> This template function makes it possible to write multi-line log messages into a file. The first line is written like a regular message, subsequent lines are indented with a tab, in compliance with RFC822.</para>
        <example>
            <title>Using the indent-multi-line template function</title>
            <para>The following example writes multi-line messages into a text file.</para>
            <synopsis>destination d_file {
        file ("/var/log/messages"
                template("${ISODATE} ${HOST} $(indent-multi-line ${MESSAGE})\n") );
};</synopsis>
        </example>
    </simplesect>
    <simplesect xml:id="template-function-ipv4-to-int">
        <title>ipv4-to-int</title>
        <indexterm>
            <primary>ipv4-to-int</primary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis>
            <synopsis>$(ipv4-to-int parameter)</synopsis></para>
        <para><emphasis role="bold">Description:</emphasis> Converts the specified IPv4 address to its numeric representation. The numerical value of an IPv4 address is calculated by treating the IP address as a 4-byte hexadecimal value. For example, the 192.168.1.1 address equals to: 192=C0, 168=A8, 1=01, 1=01, or C0A80101, which is 3232235777 in decimal representation.</para>
        <note>
            <para>This template function is available only if the <filename>convertfuncs</filename> module has been loaded. By default, &abbrev; loads every available module.</para>
            <!-- FIXME link a modulokrol szolo leirasra-->
        </note>
    </simplesect>
    <simplesect xml:id="template-function-numeric-operations" condition="pe">
        <title>Numeric operations</title>
        <indexterm>
            <primary>numeric operations</primary>
        </indexterm>
        <indexterm>
            <primary>addition</primary>
        </indexterm>
        <indexterm>
            <primary>subtraction</primary>
        </indexterm>
        <indexterm>
            <primary>multiplication</primary>
        </indexterm>
        <indexterm>
            <primary>division</primary>
        </indexterm>
        <indexterm>
            <primary>modulus</primary>
        </indexterm>
        <indexterm>
            <primary>template functions</primary>
            <secondary>numeric operations</secondary>
        </indexterm>
        <para><emphasis role="bold">Syntax:</emphasis>
            <synopsis>$(&lt;operator&gt; &lt;first_operand&gt; &lt;second_operand&gt;)</synopsis></para>
        <para><emphasis role="bold">Description:</emphasis>
        </para>
        <para>This template function performs simple numerical operations (like addition or multiplication) on integer numbers or macros containing integer numbers (for example, <parameter>${LEVEL_NUM}</parameter> or <parameter>${YEAR}</parameter>), and returns the result of the operation. The values used in the operation are not modified, that is, macros retain their original values. If one of the operands is not an integer, &abbrev; will not execute the template function, and return the <userinput>NaN</userinput> (Not-a-Number) value.</para>
        <para>Available only in &abbrev; <phrase condition="pe">4 F1</phrase> and later.</para>
        <informaltable frame="topbot" colsep="0" rowsep="0">
            <tgroup cols="2">
                <tbody>
                    <row>
                        <entry>Operator <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                        <entry>Operation: <?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
                    </row>
                    <row>
                        <entry><userinput>+</userinput></entry>
                        <entry>Addition: returns the value of <userinput>&lt;first_operand&gt;+&lt;second_operand&gt;</userinput></entry>
                    </row>
                    <row>
                        <entry><userinput>-</userinput></entry>
                        <entry>Subtraction: returns the value of <userinput>&lt;first_operand&gt;-&lt;second_operand&gt;</userinput></entry>
                    </row>
                    <row>
                        <entry><userinput>*</userinput></entry>
                        <entry>Multiplication: returns the value of <userinput>&lt;first_operand&gt;*&lt;second_operand&gt;</userinput></entry>
                    </row>
                    <row>
                        <entry><userinput>/</userinput></entry>
                        <entry>Division: returns the value of <userinput>&lt;first_operand&gt;/&lt;second_operand&gt;</userinput></entry>
                    </row>
                    <row>
                        <entry><userinput>%</userinput></entry>
                        <entry>Modulus (remainder): returns the remainder of <userinput>&lt;first_operand&gt;/&lt;second_operand&gt;</userinput></entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <warning>
            <para>The output of this template function is always an integer. If the return value would be a floating-point number, the floating part is simply omitted, for example, 5.2 becomes 5, 5.8 becomes 5, -5.8 becomes -5.</para>
        </warning>
        <para>It is also possible to nest numerical operations.</para>
        <example>
            <title>Using numerical template functions</title>
            <para>The following template function returns the facility of the log message multiplied by 8:</para>
            <synopsis>$(* ${FACILITY_NUM} 8)</synopsis>
            <para>Template functions can be nested into each other: the following template function returns the facility of the log message multiplied by 8, then adds this value to the severity of the message (the result is actually the priority of the message):</para>
            <synopsis>$(+ ${LEVEL_NUM} $(* ${FACILITY_NUM} 8))</synopsis>
        </example>
    </simplesect>
</section>
