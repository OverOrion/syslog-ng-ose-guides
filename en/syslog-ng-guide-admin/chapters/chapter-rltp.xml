<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
 [  <!ENTITY % entities SYSTEM "../../common/syslog-ng-entities.ent">
 %entities;]>
<chapter xml:id="chapter-rltp" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title><trademark>Reliable Log Transfer Protocol</trademark> </title>
    <!-- FIXME jumplist -->
    <section xml:id="concepts-rltp">
        <title>Logging using <trademark>RLTP</trademark> </title>
        <indexterm> <primary><trademark>RLTP</trademark></primary> </indexterm>
        <indexterm> <primary>log transfer protocol</primary> <secondary>reliable</secondary> </indexterm>
        <indexterm> <primary>transport</primary> <secondary>TCP</secondary> </indexterm>
        <para xml:id="para-rltp-intro">The &abbrev; application can send and receive log messages in a reliable way over the TCP transport layer using the <trademark>Reliable Log Transfer Protocol</trademark> (<trademark>RLTP</trademark>). <trademark>RLTP</trademark> is a proprietary transport protocol that prevents message loss during connection breaks. The transport is used between &abbrev; hosts (for example, a client and a server, or a client-relay-server), and interoperates with the flow-control and reliable disk-buffer mechanisms of &abbrev;, thus providing the best way to prevent message loss. The sender detects which messages has the receiver successfully received. If messages are lost during the transfer, the sender resends the missing messages, starting from the last successfully received message. Therefore, messages are not duplicated at the receiving end in case of a connection break (however, in failover mode this is not completely ensured). <trademark>RLTP</trademark> also allows to receive encrypted and non-encrypted connections on the same port, using a single source driver.</para>
        <note>
            <para>Because of the communication overhead, the <trademark>RLTP</trademark> protocol is slower than other transport protocols, which might be a problem if you need to collect a high amount (over 200000 messages per second) of log messages on your log server. For performance details of &abbrev; see the <emphasis>syslog-ng Premium Edition Performance Guideline</emphasis> at the <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="https://www.balabit.com/log-management-software/documentation">&abbrev; documentation page</link>.</para>
        </note>
        <note>
            <para>Make sure that you have set the value of the <parameter>log_msg_size()</parameter> parameter large enough in your configuration. If its size is less than the size of the sent messages, it might result in disk fill-up and no incoming logs.</para>
        </note>
        <warning>
            <xi:include href="../../common/chunk/rltp-losing-messages.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </warning>
        <para>The <trademark>RLTP</trademark> protocol works on top of TCP, and can use STARTTLS for encryption. <trademark>RLTP</trademark> supports IPv4 and IPv6 addresses. Inside the <trademark>RLTP</trademark> message, the message can use any format, for example, RFC3164 (BSD-syslog) or RFC5424 (IETF-syslog). The default port of <trademark>RLTP</trademark> is <userinput>35514</userinput>.</para>
        <para><trademark>RLTP</trademark> can be added to the configuration like a transport protocol within the <parameter>syslog()</parameter> driver and the <parameter>network()</parameter> driver.</para>
        <procedure xml:id="procedure-rltp-concepts">
            <title>How <trademark>RLTP</trademark> connections work</title>
            <indexterm> <primary><trademark>RLTP</trademark></primary> </indexterm>
            <indexterm> <primary>log transfer protocol</primary> <secondary>reliable</secondary> </indexterm>
            <indexterm> <primary>transport</primary> <secondary>TCP</secondary> </indexterm>
            <formalpara>
                <title>Purpose:</title>
                <para/>
            </formalpara>
            <para>This procedure summarizes how two &abbrev; hosts (a sender and a receiver) communicate using the <trademark>Reliable Log Transfer Protocol</trademark> (<trademark>RLTP</trademark>).</para>
            <formalpara>
                <title>Prerequisites:</title>
                <para/>
            </formalpara>
            <para>The sender (also called the client) is the host that has <trademark>RLTP</trademark> configured in its destination driver. The receiver (also called the server) is the host that has <trademark>RLTP</trademark> configured in its source driver.</para>
            <formalpara>
                <title>Steps:</title>
                <para/>
            </formalpara>
            <step>
                <para>The sender initiates the connection to the receiver.</para>
            </step>
            <step>
                <para>The sender and the receiver negotiate whether to encrypt the connection and to use compression or not.</para>
            </step>
            <step>
                <para>If the connection should be encrypted, the sender and the receiver perform authentication (as configured in the <parameter>tls()</parameter> options of their configuration).</para>
            </step>
            <step>
                <para>If the sender and the receiver have communicated earlier using <trademark>RLTP</trademark>, the receiver indicates which was the last message received from the sender.</para>
            </step>
            <step>
                <para>The sender starts sending messages in batches. Batch size depends on the <parameter>flush-lines()</parameter> parameter of the sender.</para>
                <xi:include href="../../common/chunk/para-option-destination-flush-lines-note.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </step>
            <step>
                <para>When the receiver has successfully processed the messages in the batch, it sends an acknowledgement of the processed messages to the sender.</para>
                <para>What "successfully processed" means depends on the configuration of the receiver, for example, written to disk in a destination, forwarded to a remote destination using <emphasis>not</emphasis> <trademark>RLTP</trademark>, dropped because of filter settings, or written to the disk-buffer. (If the messages are forwarded using <trademark>RLTP</trademark>, see <xref linkend="rltp-client-relay-server"/>.)</para>
            </step>
            <step>
                <para>After receiving the acknowledgement, the sender sends another batch of messages.</para>
            </step>
        </procedure>
        <section xml:id="rltp-client-relay-server">
            <title>Using <trademark>RLTP</trademark> in a client-relay-server scenario</title>
            <para>You can use <trademark>RLTP</trademark> between multiple &abbrev; hosts, for example, in a client-relay-server scenario. In such case, the communication described in <xref linkend="procedure-rltp-concepts"/> applies both between the client and the relay, and the relay and the server. However, note the following points:</para>
            <itemizedlist>
                <listitem>
                    <para>Unless you use disk-buffer on the relay, the relay waits for acknowledgement from the server before acknowledging the messages to the client. If you send the messages in large batches, and the server can process the messages slowly (or the network connection is slow), you might have to adjust the <parameter>message-acknowledgement-timeout()</parameter> on the client.</para>
                </listitem>
                <listitem>
                    <para>If you use reliable disk-buffer on the relay, the relay will acknowledge the messages when the messages are written to the disk-buffer. That way, the client does not have to wait while the server acknowledges the messages.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section xml:id="rltp-options">
        <title><trademark>RLTP</trademark> options</title>
        <para>The following options are specific to the <trademark>RLTP</trademark> protocol. Note that when using <trademark>RLTP</trademark> in a source or a destination, the options of the <parameter>syslog()</parameter> or the <parameter>network()</parameter> driver can be used as well.</para>
        <simplesect>
            <title>allow-compress()</title>
            <indexterm> <primary>allow-compress()</primary> </indexterm>
            <indexterm> <primary>allow_compress()</primary> </indexterm>
            <indexterm> <primary>compression</primary> <secondary>on-the-wire</secondary> </indexterm>
            <indexterm> <primary>on-the-wire compression</primary> </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <colspec colnum="1" colwidth="80pt"/>
                    <tbody>
                        <row>
                            <entry>Accepted values: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>yes | no</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>no</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> Enable on-the-wire compression in the RLTP communication. Note that this option must be enabled both on the server and the client side to have any effect. Enabling compression can significantly reduce the bandwidth required to transport the messages, but can slightly decrease the performance of &abbrev;, reducing the number of transferred messages. The <parameter>allow-compress()</parameter> option can be used in source and destination drivers as well. Available in &abbrev; <phrase condition="pe">5.0</phrase> and later.</para>
        </simplesect>
        <simplesect>
            <title>message-acknowledgement-timeout()</title>
            <indexterm> <primary>message-acknowledgement-timeout()</primary> </indexterm>
            <indexterm> <primary>message_acknowledgement_timeout()</primary> </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>Type: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>number (seconds)</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>900</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> When the receiver (&abbrev; server) receives and successfully processes a message, it sends an acknowledgement to the sender (the &abbrev; client). If the receiver does not acknowledge receiving the messages within this period, the sender terminates the connection with the receiver. Use this option only in destination drivers.</para>
        </simplesect>
        <simplesect>
            <title>response-timeout()</title>
            <indexterm> <primary>response-timeout()</primary> </indexterm>
            <indexterm> <primary>response_timeout()</primary> </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>Type: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>number (seconds)</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>60</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> If &abbrev; does not receive any message (acknowledgement, or other message related to the <trademark>RLTP</trademark> protocol) in the given timeframe, &abbrev; terminates the connection with the peer, and the "Connection broken" message appears in the logs of the sender (the &abbrev; client). This is normal, and happens when the sender does not send any new message to the receiver.</para>
            <para>Under normal circumstances, you should not change the value of this option. The <parameter>response-timeout()</parameter> option can be used in source and destination drivers as well.</para>
        </simplesect>
        <simplesect>
            <title>tls-required()</title>
            <indexterm> <primary>tls-required()</primary> </indexterm>
            <indexterm> <primary>tls_required()</primary> </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>Type: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>yes, optional, no</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?> </entry>
                            <entry>optional</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> Determines whether STARTTLS is to be used during communication. If the option is set to <userinput>yes</userinput>, you must also configure the <parameter>tls()</parameter> option to specify other parameters of the TLS connection (for example, the authentication of the server and the client).</para>
            <para>The <parameter>tls-required()</parameter> option can be used in source and destination drivers as well.</para>
            <para>For example, if you configure <userinput>tls-required(yes)</userinput> on server side and <userinput>tls-required(no)</userinput> on client side, the connection is dropped. If one of them is set to <userinput>optional</userinput>, the configuration of the other side will decide if TLS is used or not. If both sides are set to <userinput>optional</userinput>, and the <parameter>tls()</parameter> option is properly configured, TLS encryption will be used. The following table summarizes the possible options and their results.</para>
            <para>Note that the various parameters of the <parameter>tls()</parameter> option are considered in the connection only if the <parameter>tls-required()</parameter> settings of the peers result in <userinput>TLS-encryption</userinput> in the following table. In other words: the <parameter>tls-required()</parameter> option of <trademark>RLTP</trademark> determines if TLS should be used at all, while the <parameter>peer-verify()</parameter> option of the <parameter>tls()</parameter>setting determines if the TLS connection can be actually established.</para>
            <informaltable>
                <tgroup cols="5">
                    <colspec colnum="1" colname="col1"/>
                    <colspec colnum="2" colname="col2" colwidth="0.5*"/>
                    <colspec colnum="3" colname="col3"/>
                    <colspec colnum="4" colname="col4"/>
                    <colspec colnum="5" colname="col5"/>
                    <thead>
                        <row>
                            <entry namest="col1" nameend="col2" morerows="1"/>
                            <entry namest="col3" nameend="col5" align="center">tls-required() setting on the server</entry>
                        </row>
                        <row>
                            <entry align="center"> yes </entry>
                            <entry align="center"> no </entry>
                            <entry align="center"> optional </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry morerows="2" rotate="1" valign="middle">
                                <?dbhtml bgcolor="#D4D6EB" ?>
                                <?dbfo bgcolor="#D4D6EB" ?><emphasis role="bold">tls-required() setting on the client</emphasis> </entry>
                            <entry align="center">
                                <?dbhtml bgcolor="#D4D6EB" ?>
                                <?dbfo bgcolor="#D4D6EB" ?><emphasis role="bold">yes</emphasis> </entry>
                            <entry> TLS-encryption </entry>
                            <entry> rejected connection </entry>
                            <entry> TLS-encryption </entry>
                        </row>
                        <row>
                            <entry align="center">
                                <?dbhtml bgcolor="#D4D6EB" ?>
                                <?dbfo bgcolor="#D4D6EB" ?><emphasis role="bold">no</emphasis> </entry>
                            <entry> rejected connection </entry>
                            <entry> unencrypted connection </entry>
                            <entry> unencrypted connection </entry>
                        </row>
                        <row>
                            <entry align="center">
                                <?dbhtml bgcolor="#D4D6EB" ?>
                                <?dbfo bgcolor="#D4D6EB" ?><emphasis role="bold">optional</emphasis> </entry>
                            <entry> TLS-encryption </entry>
                            <entry> unencrypted connection </entry>
                            <entry> TLS-encryption if the <parameter>tls()</parameter> option is set, unencrypted connection otherwise </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para>Setting <userinput>tls-required(optional)</userinput> on your server allows you to receive both encrypted and unencrypted connections on the same port.</para>
        </simplesect>
    </section>
    <section xml:id="rltp-examples">
        <title>Examples for using <trademark>RLTP</trademark> </title>
        <example>
            <title>Simple <trademark>RLTP</trademark> connection</title>
            <para>The sender and the receiver use <trademark>RLTP</trademark> over the <parameter>network()</parameter> protocol. Since the <userinput>tls()</userinput> option is not configured neither on the sender nor on the receiver, the communication will be unencrypted.</para>
            <para><emphasis>Receiver configuration (&abbrev; server)</emphasis>:</para>
            <synopsis>source s_network_rltp {
        network(
            ip("127.0.0.1")
            port("5555")
            transport(rltp)
            ip-protocol(4)
        );
};</synopsis>
            <para><emphasis>Sender configuration (&abbrev; client)</emphasis>:</para>
            <synopsis>destination d_network_rltp {
        network(
            "127.0.0.1"
            port("5555")
            transport(rltp)
            ip-protocol(4)
        );
};</synopsis>
        </example>
        <example>
            <title><trademark>RLTP</trademark> with TLS encryption</title>
            <para>The following example configure a sender and a receiver to communicate using <trademark>RLTP</trademark>. Since the <parameter>tls-required()</parameter> option is set to <userinput>optional</userinput> on the receiver and <userinput>yes</userinput> on the sender, and the <parameter>tls()</parameter> option is configured, the communication will be TLS-encrypted. For the sender (&abbrev; client), reliable disk-buffering is enabled to prevent data loss.</para>
            <para><emphasis>Receiver configuration (&abbrev; server)</emphasis>:</para>
            <synopsis>source s_syslog_rltp {
        syslog(
            ip("127.0.0.1")
            port("4444")
            transport(rltp(tls-required(optional)))
            ip-protocol(4)
            tls(
                peer-verify(required-trusted)
                ca-dir("/var/tmp/client/")
                key-file("/var/tmp/server/server_priv.key")
                cert-file("/var/tmp/server/server.crt")
            )
        );
};</synopsis>
            <para><emphasis>Sender configuration (&abbrev; client)</emphasis>:</para>
            <synopsis>destination d_syslog_rltp {
        syslog(
            "127.0.0.1"
            port("4444")
            transport(rltp(tls-required(yes)))
            ip-protocol(4)
            disk-buffer( mem-buf-size(200000) disk-buf-size(2000000) reliable(yes) )
            tls(
                peer-verify(required-trusted)
                ca-dir("/var/tmp/server/")
                key-file("/var/tmp/client/client_priv.key")
                cert-file("/var/tmp/client/client.crt")
            )
        );
};</synopsis>
        </example>
    </section>
    <section>
        <title>Reliability and controlling the loss of log messages</title>
        <para><trademark>RLTP</trademark> interacts with flow control and disk buffering to ensure that the loss of log messages is minimized or is prevented completely. This section explains how each loss prevention method contributes to reliability and the controlling of log message loss. <link linkend="concepts-flow-control">Flow control</link> and <link linkend="concepts-diskbuffer">disk buffering</link> are explained in detail elsewhere in the document. In this section, we take a high-level view at all of these mechanisms and highlight considerations such as:</para>
        <itemizedlist>
            <listitem>
                <para>What best practices exist in various scenarios, how to set key parameters</para>
            </listitem>
            <listitem>
                <para>When does a log message count as "delivered"</para>
            </listitem>
            <listitem>
                <para>Under what circumstances can log loss occur</para>
            </listitem>
        </itemizedlist>
        <para>Each of the following subsections discusses a different scenario and uses figures to aid comprehension.</para>
        <note>
            <para>Each figure depicts a scenario in which the volume of incoming messages makes it necessary to use all buffers and control windows at maximum capacity. </para>
        </note>
        <simplesect>
            <title>No flow control, no disk buffering, no <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <para>As there is no loss prevention mechanism in place, when the destination servers are unable to accept messages, and the output buffer is full, syslog-ng will start discarding messages. </para>
            <figure>
                <title>No flow control, no disk buffering, no <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="no-fc-no-db-no-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/no-fc-no-db-no-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>The output buffer must be large enough to store the incoming messages of every source.</para>
            <para>When set for every source driver individually:</para>
            <para><userinput>log-fifo-size()</userinput><emphasis role="bold"> &gt; </emphasis><userinput>log-fetch-limit()</userinput> of source driver #1 <emphasis role="bold">+</emphasis> <userinput>log-fetch-limit()</userinput> of source driver #2</para>
            <para>When set globally:</para>
            <para><userinput>log-fifo-size()</userinput><emphasis role="bold"> &gt; </emphasis><userinput>log-fetch-limit()</userinput> <emphasis role="bold">*</emphasis> <userinput>number_of_connections</userinput></para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Log messages get lost if the output buffer is full when the destination server(s) become unreachable.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: FIXME</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then those messages get lost that the destination driver considers "delivered" based on the acknowledgement.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Flow control, no disk buffering, no <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <para><parameter>log-iw-size()</parameter> sets a control window that tracks how many messages &abbrev; can accept. Every source has its own control window. If the window is full, &abbrev; stops reading messages from the sources until some messages are successfully sent to the destination.</para>
            <figure>
                <title>Flow control, no disk buffering, no <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="fc-no-db-no-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/fc-no-db-no-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>The output buffer must be large enough to store the incoming messages of every source:</para>
            <para><userinput>log-fifo-size()</userinput><emphasis role="bold"> &gt; </emphasis><userinput>log-iw-size()</userinput> <emphasis role="bold">*</emphasis> <userinput>number_of_connections</userinput></para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Only as many incoming log messages are read as can be "delivered". When flow control is used, those messages are considered delivered that have been written to the output buffer. When the output buffer is full, &abbrev; will stop reading messages.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: FIXME</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then those messages get lost that the destination driver considers "delivered" based on the acknowledgement.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Flow control, normal disk buffering, no <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <orderedlist>
                <listitem>
                    <para>&abbrev; puts messages into the memory buffer (set via <parameter>mem-buf-size()</parameter>) if the output buffer is full and/or if the network connection to the destination becomes unavailable.</para>
                </listitem>
                <listitem>
                    <para>When the memory buffer gets filled up, it puts messages into the disk buffer of the destination (set via <parameter>disk-buf-size()</parameter>).</para>
                </listitem>
            </orderedlist>
            <figure>
                <title>Flow control, normal disk buffering, no <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="fc-normal-db-no-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/fc-normal-db-no-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>The output buffer must be large enough to store the incoming messages of every source:</para>
            <para><userinput>quot-size()</userinput><emphasis role="bold"> &gt; </emphasis><userinput>log-iw-size()</userinput> <emphasis role="bold">*</emphasis> <userinput>number_of_connections</userinput></para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Only as many incoming log messages are read as can be "delivered". When flow control is used in combination with disk buffering, those messages are considered delivered that have been written to the memory buffer and the disk buffer. When the disk buffer is full, &abbrev; will stop reading messages.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer and memory buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: Log messages that were in the output buffer and memory buffer when the reload/restart occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then those messages get lost that the destination driver considers "delivered" based on the acknowledgement.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Flow control, reliable disk buffering, no <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <orderedlist>
                <listitem>
                    <para>syslog-ng puts messages into the disk buffer, until disk-buffer size reaches <parameter>disk-buf-size()</parameter> minus <parameter>mem-buf-size()</parameter>.</para>
                </listitem>
                <listitem>
                    <para>Above that size, messages are written into both the disk buffer and the memory buffer, indicating that flow control needs to slow down the message source. These messages are not taken out from the control window (governed by <parameter>log-iw-size()</parameter>), causing the control window to fill up. In other words, it is the <parameter>mem-buf-size()</parameter> option that determines when flow control is triggered. If the control window is full, flow control completely stops reading incoming messages from the source. </para>
                </listitem>
            </orderedlist>
            <figure>
                <title>Flow control, reliable disk buffering, no <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="fc-reliable-db-no-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/fc-reliable-db-no-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>The memory buffer must be large enough to store the incoming messages contained in the control window:</para>
            <para><userinput>mem-buf-size()</userinput><emphasis role="bold"> &gt; = </emphasis><userinput>log-iw-size()</userinput></para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Only as many incoming log messages are read as can be "delivered". When flow control is used in combination with disk buffering, those messages are considered delivered that have been written to the memory buffer and the disk buffer. As soon as messages start being written to the memory buffer, &abbrev; will stop reading messages.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer and memory buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: Log messages that were in the output buffer and memory buffer when the reload/restart occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then those messages get lost that the destination driver considers "delivered" based on the acknowledgement.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Flow control, no disk buffering, <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <note>
                <para>The example presented here is set in a client-relay-server scenario.</para>
            </note>
            <orderedlist>
                <listitem>
                    <para>The client sends messages in batches (set via <parameter>flush-lines()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>The relay sends messages in batches (set via <parameter>flush-lines()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>When the server has successfully received and processed the messages in the batch, it sends an acknowledgement of the processed messages to the relay.</para>
                </listitem>
                <listitem>
                    <para>The relay acknowledges the successful delivery of messages to the client.</para>
                </listitem>
            </orderedlist>
            <note>
                <para>The relay waits for acknowledgement from the server before acknowledging the messages to the client. After receiving the acknowledgement, the sender sends another batch of messages.</para>
            </note>
            <figure>
                <title>Flow control, no disk buffering, <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="fc-no-db-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/fc-no-db-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>For optimal performance, batch size should be smaller than the window size of the sender:</para>
            <para><userinput>flush-lines()</userinput><emphasis role="bold"> &lt; </emphasis><userinput>log-iw-size()</userinput> of receiver</para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Only as many incoming log messages are read as can be "delivered". When flow control is used in combination with <trademark>RLTP</trademark>, those messages are considered delivered by the very first source driver that have been written to the final destination server. &abbrev; will not read new messages until the previous batch has been delivered.</para>
                    <para>In case the application sending the log messages is a blocking I/O app, then it is the application that stops sending new log messages and waits until the previous batch has been delivered. If it is a non-blocking I/O application, then it will keep sending messages (regardless of whether or not the previous batch has been delivered), and this can result in the loss of log messages.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: Log messages that were in the output buffer when the reload/restart occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then those messages get lost that the destination driver considers "delivered" based on the acknowledgement.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Flow control, normal disk buffering, <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <note>
                <para>The example presented here is set in a client-relay-server scenario.</para>
            </note>
            <orderedlist>
                <listitem>
                    <para>The client sends messages in batches (set via <parameter>flush-lines()</parameter>).</para>
                </listitem>
                <listitem>
                    <orderedlist>
                        <listitem>
                            <para>The relay writes the messages to the memory buffer.</para>
                        </listitem>
                        <listitem>
                            <para>When the memory buffer gets filled up, messages are written to the disk buffer.</para>
                        </listitem>
                    </orderedlist>
                </listitem>
                <listitem>
                    <para>Once messages have been written to the memory/disk buffer, the relay returns an acknowledgement to the client.</para>
                </listitem>
                <listitem>
                    <para>The relay sends messages to the server in batches (set via <parameter>flush-lines()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>When the server has successfully received and processed the messages in the batch, it sends an acknowledgement of the processed messages to the relay.</para>
                    <para>After receiving the acknowledgement, the sender sends another batch of messages.</para>
                </listitem>
            </orderedlist>
            <figure>
                <title>Flow control, normal disk buffering, <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="fc-normal-db-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/fc-normal-db-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>For optimal performance, batch size should be smaller than the window size of the sender:</para>
            <para><userinput>flush-lines()</userinput><emphasis role="bold"> &lt; </emphasis><userinput>log-iw-size()</userinput> of receiver</para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Only as many incoming log messages are read as can be "delivered". When flow control is used in combination with normal disk buffering and <trademark>RLTP</trademark>, those messages are considered delivered by the very first source driver that have been written to the memory buffer and the disk buffer. &abbrev; will not read new messages until the previous batch has been written to the memory and disk buffers.</para>
                    <para>In case the application sending the log messages is a blocking I/O app, then it is the application that stops sending new log messages and waits until the previous batch has been delivered. If it is a non-blocking I/O application, then it will keep sending messages (regardless of whether or not the previous batch has been delivered), and this can result in the loss of log messages.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer and the memory buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: Log messages that were in the output buffer when the reload/restart occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then without <trademark>RLTP</trademark>, those messages could get lost that the destination driver considers "delivered" based on the acknowledgement. However, while the acknowledge messages sent by the TCP socket implement flow control at the transport layer, <trademark>RLTP</trademark> introduces flow control at the application layer. This means that log messages are only considered delivered, when the <trademark>RLTP</trademark> acknowledge message is returned at the level of the syslog-ng application. That is, when the TCP kernel crashes, messages that have been written to the disk buffer do not get lost.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Flow control, reliable disk buffering, <trademark>RLTP</trademark></title>
            <formalpara>
                <title>How it works:</title>
                <para/>
            </formalpara>
            <note>
                <para>The examples presented here is set in a client-relay-server scenario.</para>
            </note>
            <orderedlist>
                <listitem>
                    <para>The sender sends messages in batches (set via <parameter>flush-lines()</parameter>).</para>
                </listitem>
                <listitem>
                    <orderedlist>
                        <listitem>
                            <para>The relay writes the messages to the disk buffer.</para>
                        </listitem>
                        <listitem>
                            <para>When the disk-buffer size reaches <parameter>disk-buf-size()</parameter>minus <parameter>mem-buf-size()</parameter>, messages are written into both the disk buffer and the memory buffer.</para>
                        </listitem>
                    </orderedlist>
                </listitem>
                <listitem>
                    <para>Once messages have been written to the memory/disk buffer, the relay returns an acknowledgement to the client.</para>
                </listitem>
                <listitem>
                    <para>The relay sends messages to the server in batches (set via <parameter>flush-lines()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>When the server has successfully received and processed the messages in the batch, it sends an acknowledgement of the processed messages to the relay.</para>
                    <para>After receiving the acknowledgement, the sender sends another batch of messages.</para>
                </listitem>
            </orderedlist>
            <figure>
                <title>Flow control, reliable disk buffering, <trademark>RLTP</trademark></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="fc-reliable-db-rltp.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/fc-reliable-db-rltp.png" scale="50"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <formalpara>
                <title>How to set key parameters:</title>
                <para/>
            </formalpara>
            <para>For optimal performance, batch size should be smaller than the window size of the sender:</para>
            <para><userinput>flush-lines()</userinput><emphasis role="bold"> &lt; </emphasis><userinput>log-iw-size()</userinput> of receiver</para>
            <formalpara>
                <title>Which log messages get lost:</title>
                <para/>
            </formalpara>
            <itemizedlist>
                <listitem>
                    <para><emphasis>Unreachable destination server(s)</emphasis>: Only as many incoming log messages are read as can be "delivered". When flow control is used in combination with reliable disk buffering and <trademark>RLTP</trademark>, those messages are considered delivered by the very first source driver that have been written to the disk buffer. &abbrev; will not read new messages until the previous batch has been written to the disk buffer.</para>
                    <para>In case the application sending the log messages is a blocking I/O app, then it is the application that stops sending new log messages and waits until the previous batch has been delivered. If it is a non-blocking I/O application, then it will keep sending messages (regardless of whether or not the previous batch has been delivered), and this can result in the loss of log messages.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; crash</emphasis>: Log messages that were in the output buffer and the memory buffer when the crash occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>&abbrev; reload</emphasis>: Log messages that were in the output buffer when the reload/restart occurred get lost because those messages are stored in the memory.</para>
                </listitem>
                <listitem>
                    <para><emphasis>Unreachable TCP kernel</emphasis>: In the case of a TCP connection, when messages are sent from the destination drivers to the destination servers, messages are first written to the buffer of the kernel's TCP socket. The TCP socket sends an acknowledgement to the destination drivers once it has successfully written messages to its buffer. If the socket crashes after having sent the acknowledgement but before messages are written to the destination server, then without <trademark>RLTP</trademark>, those messages could get lost that the destination driver considers "delivered" based on the acknowledgement. However, while the acknowledge messages sent by the TCP socket implement flow control at the transport layer, <trademark>RLTP</trademark> introduces flow control at the application layer. This means that log messages are only considered delivered, when the <trademark>RLTP</trademark> acknowledge message is returned at the level of the syslog-ng application. That is, when the TCP kernel crashes, messages that have been written to the disk buffer do not get lost.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>Controlling the loss of log messages</title>
            <para>Depending on your use case, it is worth considering which outcome is more desirable:</para>
            <itemizedlist>
                <listitem>
                    <para>an application that does not slow down or stop at the price of losing logs</para>
                </listitem>
                <listitem>
                    <para>no log messages lost at the price of a slower application or an application that stops</para>
                </listitem>
            </itemizedlist>
            <para>If you have a blocking I/O application and you prefer not to slow down or stop the application when log messages are arriving in volumes greater than &abbrev; is able to process, then consider turning flow control off on the client side. This way, you will not be using the whole application-client-server chain at full capacity, and yet still be able to spot the loss of application log messages at the beginning of the chain already, in the internal logs of the client.</para>
        </simplesect>
    </section>
</chapter>
