<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
 [  <!ENTITY % entities SYSTEM "../../common/syslog-ng-entities.ent">
 %entities;]>
<chapter xml:id="chapter-rltp" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title><trademark>Reliable Log Transfer Protocol</trademark></title>
    <!-- FIXME jumplist -->
    <section xml:id="concepts-rltp">
        <title>Logging using <trademark>RLTP</trademark></title>
        <indexterm>
            <primary><trademark>RLTP</trademark></primary>
        </indexterm>
        <indexterm>
            <primary>log transfer protocol</primary>
            <secondary>reliable</secondary>
        </indexterm>
        <indexterm>
            <primary>transport</primary>
            <secondary>TCP</secondary>
        </indexterm>
        <para xml:id="para-rltp-intro">The &abbrev; application can send and receive log messages in a reliable way over the TCP transport layer using the <trademark>Reliable Log Transfer Protocol</trademark> (<trademark>RLTP</trademark>). <trademark>RLTP</trademark> is a proprietary transport protocol that prevents message loss during connection breaks. The transport is used between &abbrev; hosts (for example, a client and a server, or a client-relay-server), and it interoperates with the flow control and reliable disk-buffer mechanisms, thus providing the best way to prevent message loss. The sender detects which messages has the receiver successfully received. If message are lost during the transfer, the sender resends the missing messages from the last received message. Therefore, messages are not duplicated at the receiving end in case of a connection break (however, in failover mode this is not completely ensured). <!-- This protocol allows a message rate of at least 200k message/second. --> <trademark>RLTP</trademark> also allows to receive encrypted and non-encrypted connections on the same port, using a single source driver.</para>
        <warning>
            <itemizedlist>
                <listitem>
                    <para>If you use <trademark>RLTP</trademark> together with non-reliable disk-buffer, it is possible to lose logs. When sending logs through a relay that is using a non-reliable disk-buffer, it is possible to lose logs if the relay crashes.</para>
                </listitem>
                <listitem>
                    <para>When sending logs through a relay that is using a non-reliable disk-buffer, it is possible that logs are duplicated if the relay crashes, or it is stopped.</para>
                </listitem>
                <listitem>
                    <para>If the underlying disk system of &abbrev; fails to write the log messages to the disk, but it does not return a write error.</para>
                </listitem>
            </itemizedlist>
        </warning>
        <para>The <trademark>RLTP</trademark> protocol works on top of TCP, and can use STARTTLS for encryption. <trademark>RLTP</trademark> supports IPv4 and IPv6 addresses. Inside the <trademark>RLTP</trademark> message, the message can use any format, for example, RFC3164 (BSD-syslog) or RFC5424 (IETF-syslog). The default port of <trademark>RLTP</trademark> is <userinput>35514</userinput>.</para>
        <para><trademark>RLTP</trademark> can be added to the configuration like a transport protocol within the <parameter>syslog()</parameter> driver and the <parameter>network()</parameter> driver.</para>
    </section>
    <section xml:id="rltp-options">
        <title><trademark>RLTP</trademark> options</title>
        <para>The following options are specific to the <trademark>RLTP</trademark> protocol. Note that when using <trademark>RLTP</trademark> in a source or a destination, the options of the <parameter>syslog()</parameter> or the <parameter>network()</parameter> driver can be used as well.</para>
        <simplesect>
            <title>allow-compress()</title>
            <indexterm type="parameter">
                <primary>allow-compress()</primary>
            </indexterm>
            <indexterm>
                <primary>compression</primary>
                <secondary>on-the-wire</secondary>
            </indexterm>
            <indexterm>
                <primary>on-the-wire compression</primary>
            </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <colspec colnum="1" colwidth="80pt"/>
                    <tbody>
                        <row>
                            <entry>Accepted values: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>yes | no</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>no</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> Enable on-the-wire compression in the RLTP communication. Note that this option must be enabled both on the server and the client side to have any effect. Enabling compression can significantly reduce the bandwidth required to transport the messages, but can slightly decrease the performance of &abbrev;, reducing the number of transferred messages. The <parameter>allow-compress()</parameter> option can be used in source and destination drivers as well. Available in &abbrev; <phrase condition="pe">5.0</phrase> and later.</para>
        </simplesect>
        <simplesect>
            <title>message_acknowledgement_timeout()</title>
            <indexterm type="parameter">
                <primary>message_acknowledgement_timeout()</primary>
            </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>Type: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>number (seconds)</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>900</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> When the receiver (&abbrev; server) receives and successfully processes a message, it sends an acknowledgement to the sender (the &abbrev; client). If the receiver does not acknowledge receiving the messages within this period, the sender terminates the connection with the receiver. Use this option only in source drivers.</para>
        </simplesect>
        <simplesect>
            <title>response_timeout()</title>
            <indexterm type="parameter">
                <primary>response_timeout()</primary>
            </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>Type: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>number (seconds)</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>60</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> If &abbrev; does not receive any message (acknowledgement, or other message related to the ) in the given timeframe, &abbrev; terminates the connection with the peer, and the "Connection broken" message appears in the logs of the sender (the &abbrev; client). This is normal, and happens when the sender does not send any new message to the receiver.</para>
            <para>Under normal circumstances, you should not change the value of this option. The <parameter>response_timeout()</parameter> option can be used in source and destination drivers as well.</para>
        </simplesect>
        <simplesect>
            <title>tls_required()</title>
            <indexterm type="parameter">
                <primary>tls_required()</primary>
            </indexterm>
            <informaltable frame="topbot" colsep="0" rowsep="0">
                <tgroup cols="2">
                    <tbody>
                        <row>
                            <entry>Type: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>yes, optional, no</entry>
                        </row>
                        <row>
                            <entry>Default: <?dbhtml bgcolor="#D4D6EB" ?></entry>
                            <entry>optional</entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para><emphasis role="bold">Description:</emphasis> Determines whether STARTTLS is to be used during communication. If the option is set to <userinput>yes</userinput>, you must also configure the <parameter>tls()</parameter> option to specify other parameters of the TLS connection (for example, the authentication of the server and the client).</para>
            <para>The <parameter>tls_required()</parameter> option can be used in source and destination drivers as well.</para>
            <para>For example, if you configure <userinput>tls_required(yes)</userinput> on server side and <userinput>tls_required(no)</userinput> on client side, the connection is dropped. If one of them is set to <userinput>optional</userinput>, the configuration of the other side will decide if TLS is used or not. If both sides are set to <userinput>optional</userinput>, and the <parameter>tls()</parameter> option is properly configured, TLS encryption will be used. The following table summarizes the possible options and their results.</para>
            <para>Note that the various parameters of the <parameter>tls()</parameter> option are considered in the connection only if the <parameter>tls_required()</parameter> settings of the peers result in <userinput>TLS-encryption</userinput> in the following table. In other words: the <parameter>tls_required()</parameter> option of <trademark>RLTP</trademark> determines if TLS should be used at all, while the <parameter>peer_verify()</parameter> option of the <parameter>tls()</parameter>setting determines if the TLS connection can be actually established.</para>
            <informaltable>
                <tgroup cols="5">
                    <colspec colnum="1" colname="col1"/>
                    <colspec colnum="2" colname="col2" colwidth="0.5*"/>
                    <colspec colnum="3" colname="col3"/>
                    <colspec colnum="4" colname="col4"/>
                    <colspec colnum="5" colname="col5"/>
                    <thead>
                        <row>
                            <entry namest="col1" nameend="col2" morerows="1"/>
                            <entry namest="col3" nameend="col5" align="center">tls_required() setting on the server</entry>
                        </row>
                        <row>
                            <entry align="center"> yes </entry>
                            <entry align="center"> no </entry>
                            <entry align="center"> optional </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry morerows="2" rotate="1" valign="middle"><?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?><emphasis role="bold">tls_required() setting on the client</emphasis></entry>
                            <entry align="center"><?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?> <emphasis role="bold">yes</emphasis> </entry>
                            <entry> TLS-encryption </entry>
                            <entry> rejected connection </entry>
                            <entry> TLS-encryption </entry>
                        </row>
                        <row>
                            <entry align="center"><?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?> <emphasis role="bold">no</emphasis> </entry>
                            <entry> rejected connection </entry>
                            <entry> unencrypted connection </entry>
                            <entry> unencrypted connection </entry>
                        </row>
                        <row>
                            <entry align="center"><?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?> <emphasis role="bold">optional</emphasis> </entry>
                            <entry> TLS-encryption </entry>
                            <entry> unencrypted connection </entry>
                            <entry> TLS-encryption </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <para>Setting <userinput>tls_required(optional)</userinput> on your server allows you to receive both encrypted and unencrypted connections on the same port.</para>
        </simplesect>
    </section>
    <section xml:id="rltp-examples">
        <title>Examples for using <trademark>RLTP</trademark></title>
        <example>
            <title>RLTP with optional TLS encryption</title>
            <para>For both source and destination sides, <parameter>tls_required</parameter> is set to optional, therefore they will communicate through TLS. For the server (source side) the <parameter>message_acknowledgement_timeout</parameter> settings ensure that the connection is terminated if no messages are received in the set timeframe. For the client (destination side), the reliable disk-buffer is set to yes, to prevent data loss.</para>
            <para><emphasis>source</emphasis></para>
            <synopsis>source s_syslog_rltp {
        syslog(
            ip("127.0.0.1")
            port("4444")
            transport(rltp(tls_required(optional) message_acknowledgement_timeout(10) ))
            ip-protocol(4)
            tls(
                peer-verify(required-trusted)
                ca_dir("/var/tmp/client/")
                key_file("/var/tmp/server/server_priv.key")
                cert_file("/var/tmp/server/server.crt")
            )
        );
};</synopsis>
            <para><emphasis>destination</emphasis></para>
            <synopsis>destination d_syslog_rltp {
        syslog(
            "127.0.0.1"
            port("4444")
            transport(rltp(tls_required(optional)))
            ip-protocol(4)
            disk-buffer( mem-buf-size(200000) disk-buf-size(2000000) reliable(yes) )
            tls(
                peer-verify(required-trusted)
                ca_dir("/var/tmp/server/")
                key_file("/var/tmp/client/client_priv.key")
                cert_file("/var/tmp/client/client.crt")
            )
        );
};</synopsis>
        </example>
        <example>
            <title>RLTP with tls_required()</title>
            <para>The source and the destination would communicate through the network protocol, but since <parameter>tls_required</parameter> is set to <userinput>yes</userinput> on the server side and <userinput>no</userinput> on the client side, the connection is terminated by the server.</para>
            <para><emphasis>source</emphasis></para>
            <synopsis>source s_network_rltp {
        network(
            ip("127.0.0.1")
            port("5555")
            transport(rltp(tls_required(yes) ))
            ip-protocol(4)
            tls(
                peer-verify(required-trusted)
                ca_dir("/var/tmp/client/")
                key_file("/var/tmp/server/server_priv.key")
                cert_file("/var/tmp/server/server.crt")
            )
        );
};</synopsis>
            <para><emphasis>destination</emphasis></para>
            <synopsis>destination d_network_rltp {
        network(
            "127.0.0.1"
            port("5555")
            transport(rltp(tls_required(no)))
            ip-protocol(4)
        );
};</synopsis>
        </example>
    </section>
</chapter>
