<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
<!ENTITY % entities SYSTEM "../../shared/syslog-ng-entities.ent">
%entities;
]>
<chapter xml:id="chapter-routing-filters" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Routing messages: log paths, flags, and filters</title>
<!-- FIXME jumplist -->
    <section xml:id="logpath">
        <title>Log paths</title>
        <indexterm significance="preferred">
            <primary>log paths</primary>
        </indexterm>
        <para>Log paths determine what happens with the incoming log messages. Messages coming from the sources listed in the log statement and matching all the filters are sent to the listed destinations.</para>
        <para>To define a log path, add a log statement to the syslog-ng configuration file using the following syntax:</para>
        <indexterm>
            <primary>log paths</primary>
            <secondary>defining</secondary>
        </indexterm>
        <xi:include href="../../shared/chunk/synopsis-log-path.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <warning>
            <para>Log statements are processed in the order they appear in the configuration file, thus the order of log paths may influence what happens to a message, especially when using filters and log flags.</para>
        </warning>
        <xi:include href="../../shared/wnt/note-element-order.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <example xml:id="log-statement-example">
            <title>A simple log statement</title>
            <xi:include href="../../shared/chunk/log-statement.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </example>
        <para>All matching log statements are processed by default, and the messages are sent to <emphasis>every</emphasis> matching destination by default. So a single log message might be sent to the same destination several times, provided the destination is listed in several log statements, and it can be also sent to several different destinations.</para>
        <indexterm>
            <primary>log paths</primary>
            <secondary>flags</secondary>
        </indexterm>
        <indexterm>
            <primary>flags</primary>
        </indexterm>
        <para>This default behavior can be changed using the <parameter>flags()</parameter> parameter. Flags apply to individual log paths, they are not global options. For details and examples on the available flags, see <xref linkend="reference-logflags"/>. The effect and use of the <parameter>flow-control</parameter> flag is detailed in <xref linkend="concepts-flow-control"/>.</para>
        <section xml:id="concepts-embedded-logpaths">
            <title>Embedded log statements</title>
            <indexterm>
                <primary>embedded log statements</primary>
            </indexterm>
            <indexterm>
                <primary>log pipes</primary>
                <secondary>embedded log statements</secondary>
            </indexterm>
            <indexterm significance="preferred">
                <primary>log statements</primary>
                <secondary>embedded</secondary>
            </indexterm>
            <para>Starting from version 3.0, syslog-ng can handle embedded log statements (also called log pipes). Embedded log statements are useful for creating complex, multi-level log paths with several destinations and use filters, parsers, and rewrite rules.</para>
            <para>For example, if you want to filter your incoming messages based on the facility parameter, and then use further filters to send messages arriving from different hosts to different destinations, you would use embedded log statements.</para>
            <figure>
                <title>Embedded log statement</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="syslog-ng-embedded-log-statement-2.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/syslog-ng-embedded-log-statement-2.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Embedded log statements include sources &mdash; and usually filters, parsers, rewrite rules, or destinations &mdash; and other log statements that can include filters, parsers, rewrite rules, and destinations. The following rules apply to embedded log statements:</para>
            <itemizedlist>
                <listitem>
                    <para>Only the beginning (also called top-level) log statement can include sources.</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements can include multiple log statements on the same level (that is, a top-level log statement can include two or more log statements).</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements can include several levels of log statements (that is, a top-level log statement can include a log statement that includes another log statement, and so on).</para>
                </listitem>
                <listitem>
                    <para>After an embedded log statement, you can write either another log statement, or the <parameter>flags()</parameter> option of the original log statement. You cannot use filters or other configuration objects. This also means that flags (except for the <parameter>flow-control</parameter> flag) apply to the entire log statement, you cannot use them only for the embedded log statement.</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements that are on the same level receive the same messages from the higher-level log statement. For example, if the top-level log statement includes a filter, the lower-level log statements receive only the messages that pass the filter.</para>
                </listitem>
            </itemizedlist>
            <figure>
                <title>Embedded log statements</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="syslog-ng-embedded-log-statement.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/syslog-ng-embedded-log-statement.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Embedded log filters can be used to optimize the processing of log messages, for example, to re-use the results of filtering and rewriting operations.</para>
            <section xml:id="configuring-embedded-logpaths">
                <title>Using embedded log statements</title>
                <para>Embedded log statements (for details, see <xref linkend="concepts-embedded-logpaths"/>) re-use the results of processing messages (for example the results of filtering or rewriting) to create complex log paths. Embedded log statements use the same syntax as regular log statements, but they cannot contain additional sources. To define embedded log statements, use the following syntax:</para>
                <synopsis xml:id="log-path-synopsis-embedded">log {
    source(s1); source(s2); ...

    optional_element(filter1|parser1|rewrite1);
    optional_element(filter2|parser2|rewrite2);
    ...
    destination(d1); destination(d2); ...

    #embedded log statement
    log {
        optional_element(filter1|parser1|rewrite1);
        optional_element(filter2|parser2|rewrite2);
        ...
        destination(d1); destination(d2); ...

        #another embedded log statement
        log {
            optional_element(filter1|parser1|rewrite1);
            optional_element(filter2|parser2|rewrite2);
            ...
            destination(d1); destination(d2); ...
        };
    };
    #set flags after the embedded log statements
    flags(flag1[, flag2...]);
};</synopsis>
                <example xml:id="example-logpath-embedded">
                    <title>Using embedded log paths</title>
                    <para>The following log path sends every message to the configured destinations: both the <userinput>d_file1</userinput> and the <userinput>d_file2</userinput> destinations receive every message of the source.</para>
                    <synopsis>log { source(s_localhost); destination(d_file1); destination(d_file2); };</synopsis>
                    <para>The next example is equivalent with the one above, but uses an embedded log statement.</para>
                    <synopsis>log { source(s_localhost); destination(d_file1);
    log { destination(d_file2); };
};</synopsis>
                    <para>The following example uses two filters:</para>
                    <itemizedlist>
                        <listitem>
                            <para>messages coming from the host <userinput>192.168.1.1</userinput> are sent to the <userinput>d_file1</userinput> destination, and</para>
                        </listitem>
                        <listitem>
                            <para>messages coming from the host <userinput>192.168.1.1</userinput> and containing the string <userinput>example</userinput> are sent to the <userinput>d_file2</userinput> destination.</para>
                        </listitem>
                    </itemizedlist>
                    <synopsis>log { source(s_localhost); filter { host(192.168.1.1); }; destination(d_file1);
    log { message("example"); destination(d_file2); };
};</synopsis>
                    <para>The following example collects logs from multiple source groups and uses the <parameter>source()</parameter> filter in the embedded log statement to select messages of the <userinput>s_network</userinput> source group.</para>
                    <synopsis>log { source(s_localhost);  filter { source(s_network); }; destination(d_file1);
    log {  filter { source(s_network); }; destination(d_file2); };
};</synopsis>
                </example>
            </section>
        </section>
        <xi:include href="junctions-channels.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="reference-logflags">
            <title>Log path flags</title>
            <para>Flags influence the behavior of syslog-ng, and the way it processes messages. The following flags may be used in the log paths, as described in <xref linkend="logpath"/>.</para>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="logflags.xml"/>
            <warning xml:id="warning-embedded-log-flags">
                <para>The <parameter>final</parameter>, <parameter>fallback</parameter>, and <parameter>catchall</parameter> flags apply only for the top-level log paths, they have no effect on embedded log paths.</para>
            </warning>
            <example xml:id="example-logpath-flags">
                <title>Using log path flags</title>
<!--<para>The following log path processes every message received to the
                    <parameter>s_localhost</parameter> source that was not processed by earlier log
                    paths. As syslog-ng processes log paths in the order they appear in the
                    configuration file, place such log paths at the end of the file. A typical situation
                    is to use filters to select the most important messages and send them to specific
                    destinations, and process the remaining messages with a fallback log path.</para>
                    <synopsis>.
                    .
                    .
                    log { source(s_localhost); destination(d_tcp); flags(fallback); };</synopsis>-->
                <para>Let's suppose that you have two hosts (<userinput>myhost_A</userinput> and <userinput>myhost_B</userinput>) that run two applications each (<userinput>application_A</userinput> and <userinput>application_B</userinput>), and you collect the log messages to a central syslog-ng server. On the server, you create two log paths:</para>
                <itemizedlist>
                    <listitem>
                        <para>one that processes only the messages sent by <userinput>myhost_A</userinput>, and</para>
                    </listitem>
                    <listitem>
                        <para>one that processes only the messages sent by <userinput>application_A</userinput>.</para>
                    </listitem>
                </itemizedlist>
                <para>This means that messages sent by <userinput>application_A</userinput> running on <userinput>myhost_A</userinput> will be processed by both log paths, and the messages of <userinput>application_B</userinput> running on <userinput>myhost_B</userinput> will not be processed at all.</para>
                <itemizedlist>
                    <listitem>
                        <para>If you add the <parameter>final</parameter> flag to the first log path, then only this log path will process the messages of <userinput>myhost_A</userinput>, so the second log path will receive only the messages of <userinput>application_A</userinput> running on <userinput>myhost_B</userinput>.</para>
                    </listitem>
                    <listitem>
                        <para>If you create a third log path that includes the <parameter>fallback</parameter> flag, it will process the messages not processed by the first two log paths, in this case, the messages of <userinput>application_B</userinput> running on <userinput>myhost_B</userinput>.</para>
                    </listitem>
                    <listitem>
                        <para>Adding a fourth log path with the <parameter>catchall</parameter> flag would process every message received by the syslog-ng server.</para>
                        <synopsis>log { source(s_localhost); destination(d_file); flags(catchall); };</synopsis>
                    </listitem>
                </itemizedlist>
                <para>The following example shows a scenario that can result in message loss. Do NOT use such a configuration, unless you know exactly what you are doing. The problem is if a message matches the filters in the first part of the first log path, &abbrev; treats the message as 'processed'. Since the first log path includes the <parameter>final</parameter> flag, &abbrev; will not pass the message to the second log path (the one with the <parameter>fallback</parameter> flag). As a result, &abbrev; drops messages that do not match the filter of the embedded log path.</para>
                <synopsis># Do not use such a configuration, unless you know exactly what you are doing.
log {
    source(s_network);
    # Filters in the external log path.
    # If a message matches this filter, it is treated as 'processed'
    filter(f_program);
    filter(f_message);
    log {
        # Filter in the embedded log path.
        # If a message does not match this filter, it is lost, it will not be processed by the 'fallback' log path
        filter(f_host);
        destination(d_file1);
    };
    flags(final);
};

log {
    source(s_network);
    destination(d_file2);
    flags(fallback);
};</synopsis>
            </example>
            <example>
                <title>Using the <parameter>drop-unmatched</parameter> flag</title>
                <para>In the following example, if a log message arrives whose <userinput>$MSG</userinput> part does not contain the string <userinput>foo</userinput>, then &abbrev; will discard the message and will not check compliance with the second <userinput>if</userinput> condition.</para>
                <synopsis>...
if {
    filter { message('foo') };
    <emphasis role="bold">flags(drop-unmatched)</emphasis>
};
if {
    filter { message('bar') };
};
...</synopsis>
                <para>(Without the <parameter>drop-unmatched</parameter> flag, &abbrev; would check if the message complies with the second <userinput>if</userinput> condition, that is, whether or not the message contains the string <userinput>bar</userinput> .)</para>
            </example>
        </section>
    </section>
    <section xml:id="concepts-flow-control">
        <title>Managing incoming and outgoing messages with flow-control</title>
        <indexterm>
            <primary>log paths</primary>
            <secondary>flow-control</secondary>
        </indexterm>
        <indexterm>
            <primary>flow-control</primary>
        </indexterm>
        <indexterm>
            <primary>preventing message loss</primary>
            <secondary>flow-control</secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>log-fetch-limit()</parameter></secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>log-fifo-size()</parameter></secondary>
        </indexterm>
        <para>This section describes the internal message-processing model of syslog-ng, as well as the flow-control feature that can prevent message losses. To use flow-control, the <parameter>flow-control</parameter> flag must be enabled for the particular log path.</para>
        <para>The syslog-ng application monitors (polls) the sources defined in its configuration file, periodically checking each source for messages. When a log message is found in one of the sources, syslog-ng polls every source and reads the available messages. These messages are processed and put into the output buffer of syslog-ng (also called fifo). From the output buffer, the operating system sends the messages to the appropriate destinations.</para>
        <para>In large-traffic environments many messages can arrive during a single poll loop, therefore syslog-ng reads only a fixed number of messages from each source. The <parameter>log-fetch-limit()</parameter> option specifies the number of messages read during a poll loop from a single source.</para>
        <figure>
            <title>Managing log messages in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="io1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io1.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <indexterm>
            <primary>output buffer</primary>
        </indexterm>
        <para>Every destination has its own output buffer. The output buffer is needed because the destination might not be able to accept all messages immediately. The <parameter>log-fifo-size()</parameter> parameter sets the size of the output buffer. The output buffer must be larger than the <parameter>log-fetch-limit()</parameter> of the sources, to ensure that every message read during the poll loop fits into the output buffer. If the log path sends messages to a destination from multiple sources, the output buffer must be large enough to store the incoming messages of every source.</para>
        <para>TCP and unix-stream sources can receive the logs from several incoming connections (for example many different clients or applications). For such sources, syslog-ng reads messages from every connection, thus the <parameter>log-fetch-limit()</parameter> parameter applies individually to every connection of the source.</para>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>log-iw-size()</parameter></secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>max-connections()</parameter></secondary>
        </indexterm>
        <figure>
            <title>Managing log messages of TCP sources in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="io2.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io2.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>The flow-control of syslog-ng introduces a control window to the source that tracks how many messages can syslog-ng accept from the source. Every message that syslog-ng reads from the source lowers the window size by one, every message that syslog-ng successfully sends from the output buffer increases the window size by one. If the window is full (that is, its size decreases to zero), syslog-ng stops reading messages from the source. The initial size of the control window is by default <userinput>100</userinput>: the <parameter>log-fifo-size()</parameter> must be larger than this value in order for flow-control to have any effect. If a source accepts messages from multiple connections, all messages use the same control window.</para>
        <note>
            <para>If the source can handle multiple connections (for example, <parameter>network()</parameter>), the size of the control window is divided by the value of the <parameter>max-connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
        </note>
        <para>When flow-control is used, every source has its own control window. As a worst-case situation, the output buffer of the destination must be set to accommodate all messages of every control window, that is, the <parameter>log-fifo-size()</parameter> of the destination must be greater than <userinput>number_of_sources</userinput>*<parameter>log-iw-size()</parameter>. This applies to every source that sends logs to the particular destination. Thus if two sources having several connections and heavy traffic send logs to the same destination, the control window of both sources must fit into the output buffer of the destination. Otherwise, syslog-ng does not activate the flow-control, and messages may be lost.</para>
        <para>The syslog-ng application handles outgoing messages the following way:</para>
        <figure>
            <title>Handling outgoing messages in &abbrev;</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60" fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>output queue</primary>
                </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to the target syslog-ng server. The syslog-ng application puts the outgoing messages directly into the output queue, unless the output queue is full. The output queue can hold 64 messages, this is a fixed value and cannot be modified.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>disk queue</primary>
                    <secondary>disk buffer</secondary>
                </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full and disk-buffering is enabled, syslog-ng Premium Edition puts the outgoing messages into the disk buffer of the destination.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>overflow queue</primary>
                    <secondary>output buffer</secondary>
                </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full<phrase condition="pe"> and the disk buffer is disabled or full</phrase>, syslog-ng puts the outgoing messages into the overflow queue of the destination. (The overflow queue is identical to the output buffer used by other destinations.) The <parameter>log-fifo-size()</parameter> parameter specifies the number of messages stored in the overflow queue. For details on sizing the <parameter>log-fifo-size()</parameter> parameter, see <xref linkend="concepts-flow-control"/>.</para>
            </listitem>
        </itemizedlist>
        <para>There are two types of flow-control: Hard flow-control and soft flow-control.</para>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>soft</secondary>
                </indexterm>
                <para><emphasis>Soft flow-control:</emphasis> In case of soft flow-control there is no message lost if the destination can accept messages, but it is possible to lose messages if it cannot accept messages (for example non-writeable file destination, or the disk becomes full), and all buffers are full. Soft flow-control cannot be configured, it is automatically available for file <phrase condition="pe"> and logstore </phrase>destinations.</para>
                <example>
                    <title>Soft flow-control</title>
                    <synopsis>source s_file { file("/tmp/input_file.log"); };
destination d_file { file("/tmp/output_file.log"); };
destination d_tcp { network("127.0.0.1" port(2222) log-fifo-size(1000)); };
log { source(s_file); destination(d_file); destination(d_tcp); };
</synopsis>
                </example>
                <warning>
                    <para>Hazard of data loss! For destinations other than file<phrase condition="pe"> and logstore</phrase>, soft flow-control is not available. Thus, it is possible to lose log messages on those destinations. To avoid data loss on those destinations, use hard flow-control.</para>
                </warning>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>hard</secondary>
                </indexterm>
                <para><emphasis>Hard flow-control:</emphasis> In case of hard flow-control there is no message lost. To use hard flow-control, enable the <parameter>flow-control</parameter> flag in the log path. Hard flow-control is available for all destinations.</para>
                <example>
                    <title>Hard flow-control</title>
                    <synopsis>source s_file { file("/tmp/input_file.log"); };
destination d_file { file("/tmp/output_file.log"); };
destination d_tcp { network("127.0.0.1" port(2222) log-fifo-size(1000)); };
log { source(s_file); destination(d_file); destination(d_tcp); flags(flow-control); };
</synopsis>
                </example>
            </listitem>
        </itemizedlist>
        <xi:include href="../../shared/chunk/flow-control-multiple-destinations.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="configuring-flow-control">
            <title>Configuring flow-control</title>
            <indexterm>
                <primary>log paths</primary>
                <secondary>flow-control</secondary>
            </indexterm>
            <indexterm>
                <primary>flow-control</primary>
            </indexterm>
            <indexterm>
                <primary>preventing message loss</primary>
                <secondary>flow-control</secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>log-fetch-limit()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>log-fifo-size()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>log-iw-size()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>max-connections()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>output buffer</primary>
            </indexterm>
            <para>For details on how flow-control works, see <xref linkend="concepts-flow-control"/>. The summary of the main points is as follows:</para>
            <itemizedlist>
                <listitem>
                    <para>The syslog-ng application normally reads a maximum of <parameter>log-fetch-limit()</parameter> number of messages from a source.</para>
                </listitem>
                <listitem>
                    <para>From TCP and unix-stream sources, syslog-ng reads a maximum of <parameter>log-fetch-limit()</parameter> from every connection of the source. The number of connections to the source is set using the <parameter>max-connections()</parameter> parameter.</para>
                </listitem>
                <listitem>
                    <para>Every destination has an output buffer (<parameter>log-fifo-size()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>Flow-control uses a control window to determine if there is free space in the output buffer for new messages. Every source has its own control window, the <parameter>log-iw-size()</parameter> parameter sets the size of the control window.</para>
                </listitem>
                <listitem>
                    <para>When a source accepts multiple connections, the size of the control window is divided by the value of the <parameter>max-connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
                </listitem>
                <listitem>
                    <para>The output buffer must be larger than the control window of every source that logs to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the control window is full, syslog-ng stops reading messages from the source until some messages are successfully sent to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the output buffer becomes full, and <phrase condition="pe">neither disk-buffering nor flow-control is</phrase> <phrase condition="ose">flow-control is not</phrase> used, messages may be lost.</para>
                </listitem>
            </itemizedlist>
            <warning>
                <para>If you modify the <parameter>max-connections()</parameter> or the <parameter>log-fetch-limit()</parameter> parameter, do not forget to adjust the <parameter>log-iw-size()</parameter> and <parameter>log-fifo-size()</parameter> parameters accordingly.</para>
            </warning>
            <example>
                <title>Sizing parameters for flow-control</title>
                <indexterm>
                    <primary>log paths</primary>
                    <secondary>flow-control</secondary>
                </indexterm>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>example</secondary>
                </indexterm>
                <para>Suppose that syslog-ng has a source that must accept up to 300 parallel connections. Such situation can arise when a network source receives connections from many clients, or if many applications log to the same socket. Therefore, set the <parameter>max-connections()</parameter> parameter of the source to <userinput>300</userinput>. However, the <parameter>log-fetch-limit()</parameter> (default value: 10) parameter applies to every connection of the source individually, while the <parameter>log-iw-size()</parameter> (default value: 1000) parameter applies to the source. In a worst-case scenario, the destination does not accept any messages, while all 300 connections send at least <parameter>log-fetch-limit()</parameter> number of messages to the source during every poll loop. Therefore, the control window must accommodate at least <parameter>max-connections()</parameter>*<parameter>log-fetch-limit()</parameter> messages to be able to read every incoming message of a poll loop. In the current example this means that (<parameter>log-iw-size()</parameter> should be greater than <userinput>300*10=3000</userinput>. If the control window is smaller than this value, the control window might fill up with messages from the first connections &mdash; causing syslog-ng to read only one message of the last connections in every poll loop.</para>
                <para>The output buffer of the destination must accommodate at least <parameter>log-iw-size()</parameter> messages, but use a greater value: in the current example <userinput>3000*10=30000</userinput> messages. That way all incoming messages of ten poll loops fit in the output buffer. If the output buffer is full, syslog-ng does not read any messages from the source until some messages are successfully sent to the destination.</para>
                <synopsis>source s_localhost {
            network(ip(127.0.0.1) port(1999) max-connections(300)); };
destination d_tcp {
            network("10.1.2.3" port(1999) localport(999) log-fifo-size(30000)); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
                <para>If other sources send messages to this destination, than the output buffer must be further increased. For example, if a network host with maximum <userinput>100</userinput> connections also logs into the destination, than increase the <parameter>log-fifo-size()</parameter> by <userinput>10000</userinput>.</para>
                <synopsis>source s_localhost {
            network(ip(127.0.0.1) port(1999) max-connections(300)); };
source s_tcp {
            network(ip(192.168.1.5) port(1999) max-connections(100)); };
destination d_tcp {
            network("10.1.2.3" port(1999) localport(999) log-fifo-size(40000)); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
            </example>
        </section>
    </section>
    <section xml:id="concepts-diskbuffer">
        <title>Using disk-based and memory buffering</title>
        <indexterm significance="preferred">
            <primary>disk buffer</primary>
        </indexterm>
        <indexterm>
            <primary>disk-based buffering</primary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary>log-disk-fifo-size()</secondary>
        </indexterm>
<!-- FIXME should be merged/streamlined with the flow control section -->
        <para>The &product; application can store messages on the local hard disk if the destination (for example, the central log server) or the network connection to the destination becomes unavailable. The &abbrev; application automatically sends the stored messages to the destination when the connection is reestablished. The disk buffer is used as a queue: when the connection to the destination is reestablished, &abbrev; sends the messages to the destination in the order they were received.</para>
        <note>
            <para>Disk-based buffering can be used in conjunction with flow-control. For details on flow-control, see <xref linkend="concepts-flow-control"/>.</para>
        </note>
        <xi:include href="../../shared/chunk/p-disk-buffer-drivers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <para>Every such destination uses a separate disk buffer (similarly to the output buffers controlled by <parameter>log-fifo-size()</parameter>). The hard disk space is not pre-allocated, so ensure that there is always enough free space to store the disk buffers even when the disk buffers are full.</para>
        <para>If &abbrev; is restarted (using the <command>/etc/init.d/syslog-ng restart</command> command, or another appropriate command on your platform), it automatically saves any unsent messages from the disk buffer and the output queue. After the restart, &abbrev; sends the saved messages to the destination. In other words, the disk buffer is persistent. The disk buffer is also resistant to &abbrev; crashes.</para>
        <para>The &abbrev; application supports two types of disk buffering: reliable and normal. For details, see <xref linkend="configuring-diskbuffer-reliable"/> and <xref linkend="configuring-diskbuffer-normal"/>, respectively.</para>
        <formalpara>
            <title>Message handling and normal disk-based buffering</title>
            <para>When you use disk-based buffering, and the <parameter>reliable()</parameter> option is set to <userinput>no</userinput>, &abbrev; handles outgoing messages the following way:</para>
        </formalpara>
        <figure>
            <title>Handling outgoing messages in &abbrev;</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60" fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>output queue</primary>
                </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to the destination (for example, your central log server). The &abbrev; application puts the outgoing messages directly into the output queue, unless the output queue is full. By default, the output queue can hold 64 messages (you can adjust it using the <parameter>quot-size()</parameter> option).</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>disk queue</primary>
                    <see>disk buffer</see>
                </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full, disk-buffering is enabled, and <parameter>reliable()</parameter> is set to <userinput>no</userinput>, &abbrev; puts the outgoing messages into the disk buffer of the destination. (The disk buffer is enabled if the <parameter>disk-buffer()</parameter> option is configured.)</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>overflow queue</primary>
                    <see>output buffer</see>
                </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full and the disk buffer is disabled or full, &abbrev; puts the outgoing messages into the overflow queue of the destination. (The overflow queue is identical to the output buffer used by other destinations.) The <parameter>log-fifo-size()</parameter> parameter specifies the number of messages stored in the overflow queue. For details on sizing the <parameter>log-fifo-size()</parameter> parameter, see also <xref linkend="concepts-flow-control"/>.</para>
            </listitem>
        </itemizedlist>
        <note>
            <para>Using disk buffer can significantly decrease performance.</para>
        </note>
        <formalpara>
            <title>Message handling and reliable disk-based buffering</title>
            <para>When you use disk-based buffering, and the <parameter>reliable()</parameter> option is set to <userinput>yes</userinput>, &abbrev; handles outgoing messages the following way.</para>
        </formalpara>
<!-- FIXME figure/low-chart needed -->
        <para>The <parameter>mem-buf-size()</parameter> option determines when flow-control is triggered. All messages arriving to the log path that includes the destination using the disk-buffer are written into the disk-buffer, until the size of the disk-buffer reaches (<parameter>disk-buf-size()</parameter> minus <parameter>mem-buf-size()</parameter>). Above that size, messages are written into both the disk-buffer and the memory-buffer, indicating that flow-control needs to slow down the message source. These messages are not taken out from the control window (governed by <parameter>log-iw-size()</parameter>), causing the control window to fill up. If the control window is full, the flow-control completely stops reading incoming messages from the source. (As a result, <parameter>mem-buf-size()</parameter> must be at least as large as <parameter>log-iw-size()</parameter>.)</para>
        <section xml:id="configuring-diskbuffer-reliable">
            <title>Enabling reliable disk-based buffering</title>
            <xi:include href="../../shared/chunk/p-disk-buffer-drivers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <para>To enable reliable disk-based buffering, use the <userinput>disk-buffer(reliable(yes))</userinput> parameter in the destination. Use reliable disk-based buffering if you do not want to lose logs in case of reload/restart, unreachable destination or &abbrev; crash. This solution provides a slower, but reliable disk-buffer option. It is created and initialized at startup and gradually grows as new messages arrive. The filename of the reliable disk buffer file is the following: <filename>&lt;syslog-ng path&gt;/var/syslog-ng-00000.rqf</filename>.</para>
            <example>
                <title>Example for using reliable disk-based buffering</title>
                <synopsis>destination d_BSD {
    network(
            "127.0.0.1"
            port(3333)
            disk-buffer(
                mem-buf-size(10000)
                disk-buf-size(2000000)
                reliable(yes)
            )
        );
}; </synopsis>
            </example>
            <para>For details on the differences between normal and reliable disk-based buffering, see also <xref linkend="about-disk-buffer-files"/>.</para>
        </section>
        <section xml:id="configuring-diskbuffer-normal">
            <title>Enabling normal disk-based buffering</title>
            <xi:include href="../../shared/chunk/p-disk-buffer-drivers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <para>To enable normal disk-based buffering, use the <userinput>disk-buffer(reliable(no))</userinput> parameter in the destination. Use normal disk-based buffering if you want a solution that is faster than the reliable disk-based buffering. In this case, disk buffering will be less reliable and it is possible to lose logs in case of &abbrev; crash. The filename of the normal disk buffer file is the following: <filename>&lt;syslog-ng path&gt;/var/syslog-ng-00000.qf</filename>.</para>
            <example>
                <title>Example for using normal disk-based buffering</title>
                <para>When using the disk-buffer plugin</para>
                <synopsis>destination d_BSD {
    network(
            "127.0.0.1"
            port(3333)
            disk-buffer(
                mem-buf-length(10000)
                disk-buf-size(2000000)
                reliable(no)
            )
        );
        }; </synopsis>
            </example>
            <para>For details on the differences between normal and reliable disk-based buffering, see also <xref linkend="about-disk-buffer-files"/>.</para>
        </section>
        <section xml:id="configuring-diskbuffer-memory">
            <title>Enabling memory buffering</title>
            <para>To enable memory buffering, use the <parameter>log-fifo-size()</parameter> parameter in the destination. All destination drivers can use memory buffering. Use memory buffering if you want to send logs to destinations where disk-based buffering is not available. Or if you want the fastest solution, and if &abbrev; crash or network downtime is never expected. In these cases, losing logs is possible. This solution does not use disk-based buffering, logs are stored only in the memory.</para>
            <example>
                <title>Example for using memory buffering</title>
                <synopsis>destination d_BSD {
    network(
            "127.0.0.1"
            port(3333)
            log-fifo-size(10000)
        );
};</synopsis>
            </example>
        </section>
        <section xml:id="about-disk-buffer-files">
            <title>About disk queue files</title>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../shared/chunk/topic-about-disk-queue-files.xml"/>
        </section>
    </section>
    <section xml:id="concepts-failover" condition="pe">
        <title>Client-side failover</title>
        <indexterm>
            <primary>secondary servers</primary>
        </indexterm>
        <indexterm>
            <primary>failover servers</primary>
        </indexterm>
        <indexterm>
            <primary>fail-over servers</primary>
        </indexterm>
        <indexterm>
            <primary>tcp failover</primary>
        </indexterm>
        <indexterm>
            <primary>fail-over</primary>
        </indexterm>
        <indexterm>
            <primary>client-side failover</primary>
        </indexterm>
        <indexterm>
            <primary>FailoverSyslogServer</primary>
        </indexterm>
        <para>&abbrev; can detect if the remote server of a network destination becomes unaccessible, and start sending messages to a secondary server. Multiple failover servers can be configured, so if the secondary server becomes unaccessible as well, &abbrev; will switch to the third server in the list, and so on. If there are no more failover servers left, &abbrev; returns to the beginning of a list and attempts to connect to the primary server.</para>
        <para>When &abbrev; starts up, it will always try to connect to the primary server first, but once it fails over to a secondary server, it will not automatically attempt to return to the primary server even if it becomes available. If &abbrev; is restarted, it will attempt to connect the primary server. Reloading the configuration of &abbrev; will not cause &abbrev; to return to the primary server, unless the configuration of the destination has changed.</para>
        <para>If &abbrev; uses TLS-encryption to communicate with the remote server, &abbrev; checks the certificate of the failover server as well. The certificates of the failover servers should match their domain names or IP addresses &mdash; for details, see <xref linkend="tls-serverauth"/>. Note that when mutual authentication is used, the &abbrev; client sends the same certificate to every server.</para>
        <para>The primary server and the failover servers must be accessible with the same communication method: it is not possible to use different destination drivers or options for the different servers.</para>
        <note>
            <para>Client-side failover works only for TCP-based connections (including TLS-encrypted connections), that is, the <parameter>syslog()</parameter> and <parameter>network()</parameter> destination drivers (excluding UDP transport).</para>
            <para>Client-side failover is not supported in the <parameter>sql()</parameter> driver, even though it may use a TCP connection to access a remote database.</para>
        </note>
        <para>For details on configuring failover servers, see <xref linkend="reference-destination-network-chapter"/> and <xref linkend="reference-destination-syslog-chapter"/>.</para>
    </section>
    <section xml:id="filters">
        <title>Filters</title>
        <indexterm significance="preferred">
            <primary>filters</primary>
        </indexterm>
        <indexterm significance="preferred">
            <primary>regular expressions</primary>
        </indexterm>
        <para>The following sections describe how to select and filter log messages.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="configuring-filters"/> describes how to configure and use filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-boolean"/> shows how to create complex filters using boolean operators.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-comparing"/> explains how to evaluate macros in filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="regular-expr"/> provides tips on using regular expressions.</para>
            </listitem>
            <listitem>
                <para><xref linkend="tagging-messages"/> explains how to tag messages and how to filter on the tags.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-filters"/> is a detailed description of the filter functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section xml:id="configuring-filters">
            <title>Using filters</title>
            <para>Filters perform log routing within syslog-ng: a message passes the filter if the filter expression is true for the particular message. If a log statement includes filters, the messages are sent to the destinations only if they pass all filters of the log path. For example, a filter can select only the messages originating from a particular host. Complex filters can be created using filter functions and logical boolean expressions.</para>
            <para>To define a filter, add a filter statement to the syslog-ng configuration file using the following syntax:</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>defining</secondary>
            </indexterm>
            <synopsis>filter &lt;identifier&gt; { &lt;filter_type&gt;("&lt;filter_expression&gt;"); };</synopsis>
            <para>Then use the filter in a log path, for example:</para>
            <synopsis>log {
    source(s1);
    filter(&lt;identifier&gt;);
    destination(d1); };</synopsis>
            <para>You can also define the filter inline. For details, see <xref linkend="inline-objects"/>.</para>
            <synopsis/>
            <example>
                <title>A simple filter statement</title>
                <para>The following filter statement selects the messages that contain the word <userinput>deny</userinput> and come from the host <userinput>example</userinput>.</para>
                <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")) };
log {
    source(s1);
    filter(demo_filter);
    destination(d1); };</synopsis>
                <para>The following example does the same, but defines the filter inline.</para>
                <synopsis>log {
    source(s1);
    filter { host("example") and match("deny" value("MESSAGE")) };
    destination(d1); };</synopsis>
            </example>
        </section>
        <section xml:id="filters-boolean">
            <title>Combining filters with boolean operators</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>boolean operators</secondary>
            </indexterm>
            <indexterm>
                <primary>filters</primary>
                <secondary>AND, OR, NOT</secondary>
            </indexterm>
            <indexterm>
                <primary>boolean operators</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>AND</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>OR</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>NOT</primary>
            </indexterm>
            <para>When a log statement includes multiple filter statements, syslog-ng sends a message to the destination only if all filters are true for the message. In other words, the filters are connected with the logical <userinput>AND</userinput> operator. In the following example, no message arrives to the destination, because the filters are exclusive (the hostname of a client cannot be <userinput>example1</userinput> and <userinput>example2</userinput> at the same time):</para>
            <synopsis>filter demo_filter1 { host("example1"); };
filter demo_filter2 { host("example2"); };
log {
    source(s1); source(s2);
    filter(demo_filter1); filter(demo_filter2);
    destination(d1); destination(d2); };</synopsis>
            <para>To select the messages that come from either host <userinput>example1</userinput> or <userinput>example2</userinput>, use a single filter expression:</para>
            <synopsis>filter demo_filter { host("example1") or host("example2"); };
log {
    source(s1); source(s2);
    filter(demo_filter);
    destination(d1); destination(d2); };</synopsis>
            <para>Use the <userinput>not</userinput> operator to invert filters, for example, to select the messages that were not sent by host <userinput>example1</userinput>:</para>
            <synopsis>filter demo_filter { not host("example1"); };</synopsis>
            <para>However, to select the messages that were not sent by host <userinput>example1</userinput> or <userinput>example2</userinput>, you have to use the <userinput>and</userinput> operator (that's how boolean logic works):</para>
            <synopsis>filter demo_filter { not host("example1") and not host("example2"); };</synopsis>
            <para>Alternatively, you can use parentheses to avoid this confusion:</para>
            <synopsis>filter demo_filter { not (host("example1") or host("example2")); };</synopsis>
            <para>For a complete description on filter functions, see <xref linkend="reference-filters"/>.</para>
            <para>The following filter statement selects the messages that contain the word <userinput>deny</userinput> and come from the host <userinput>example</userinput>.</para>
            <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")); };</synopsis>
            <para>The <parameter>value()</parameter> parameter of the <parameter>match</parameter> function limits the scope of the function to the text part of the message (that is, the part returned by the <parameter>${MESSAGE}</parameter> macro). For details on using the <parameter>match()</parameter> filter function, see <xref linkend="reference-filters-match"/>.</para>
            <tip>
                <para>Filters are often used together with log path flags. For details, see <xref linkend="reference-logflags"/>.</para>
            </tip>
        </section>
        <section xml:id="filters-comparing">
            <title>Comparing macro values in filters</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>comparing values</secondary>
            </indexterm>
            <indexterm type="parameter">
                <primary>ge</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>gt</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>eq</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>ne</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>le</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>lt</primary>
            </indexterm>
            <indexterm>
                <primary>string comparison</primary>
            </indexterm>
            <indexterm>
                <primary>value comparison</primary>
            </indexterm>
            <indexterm>
                <primary>comparing values</primary>
            </indexterm>
            <indexterm>
                <primary>filters</primary>
                <secondary>comparing values</secondary>
            </indexterm>
            <para>Starting with &abbrev; version <phrase condition="ose">3.2</phrase><phrase condition="pe">4 F1</phrase>, it is also possible to compare macro values and templates as numerical and string values. String comparison is alphabetical: it determines if a string is alphabetically greater or equal to another string. Use the following syntax to compare macro values or templates. For details on macros and templates, see <xref linkend="customizing-message-format"/>.</para>
            <synopsis>filter &lt;filter-id&gt;
        {"&lt;macro-or-template&gt;" operator "&lt;value-or-macro-or-template&gt;"};</synopsis>
            <example xml:id="example-comparison">
                <title>Comparing macro values in filters</title>
                <para>The following expression selects log messages containing a PID (that is, <parameter>${PID}</parameter> macro is not empty):</para>
                <synopsis>filter f_pid {"${PID}" !=""};</synopsis>
                <para>The following expression selects log messages that do not contain a PID. Also, it uses a template as the left argument of the operator and compares the values as strings:</para>
                <synopsis>filter f_pid {"${HOST}${PID}" eq "${HOST}"};</synopsis>
                <para>The following example selects messages with priority level 4 or higher.</para>
                <synopsis>filter f_level {"${LEVEL_NUM}" &gt; "5"};</synopsis>
            </example>
            <para>Note that:</para>
            <itemizedlist>
                <listitem>
                    <para>The macro or template must be enclosed in double-quotes.</para>
                </listitem>
                <listitem>
                    <para>The <userinput>$</userinput> character must be used before macros.</para>
                </listitem>
                <listitem>
                    <para>Using comparator operators can be equivalent to using filter functions, but is somewhat slower. For example, using <userinput>"${HOST}" eq "myhost"</userinput> is equivalent to using <userinput>host("myhost" type(string))</userinput>.</para>
                </listitem>
                <listitem>
                    <para>You can use any macro in the expression, including user-defined macros from parsers and results of pattern database classifications.</para>
                </listitem>
                <listitem>
                    <para>The results of filter functions are boolean values, so they cannot be compared to other values.</para>
                </listitem>
                <listitem>
                    <para>You can use boolean operators to combine comparison expressions.</para>
<!-- FIXME add a working example-->
                </listitem>
            </itemizedlist>
            <para>The following operators are available:</para>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="table-numerical.xml"/>
        </section>
        <section xml:id="regular-expr">
            <title>Using wildcards, special characters, and regular expressions in filters</title>
            <indexterm>
                <primary>regular expressions</primary>
            </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions accept regular expressions as parameters. The exact type of the regular expression to use can be specified with the <parameter>type()</parameter> option. By default, &abbrev; uses PCRE regular expressions.</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>wildcards</secondary>
            </indexterm>
            <para>In regular expressions, the asterisk (<userinput>*</userinput>) character means 0, 1 or any number of the previous expression. For example, in the <userinput>f*ilter</userinput> expression the asterisk means 0 or more f letters. This expression matches for the following strings: <userinput>ilter</userinput>, <userinput>filter</userinput>, <userinput>ffilter</userinput>, and so on. To achieve the wildcard functionality commonly represented by the asterisk character in other applications, use <userinput>.*</userinput> in your expressions, for example <userinput>f.*ilter</userinput>.</para>
            <para>Alternatively, if you do not need regular expressions, only wildcards, use <userinput>type(glob)</userinput> in your filter:</para>
            <example xml:id="example-wildcard-filter">
                <title>Filtering with widcards</title>
                <para>The following filter matches on hostnames starting with the <userinput>myhost</userinput> string, for example, on <userinput>myhost-1</userinput>, <userinput>myhost-2</userinput>, and so on.</para>
                <synopsis>filter f_wildcard {host("myhost*" type(glob));};</synopsis>
            </example>
            <para>For details on using regular expressions in &abbrev;, see <xref linkend="regular-expr"/>.</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>control characters</secondary>
            </indexterm>
            <para>To filter for special control characters like the carriage return (CR), use the <userinput>\r</userinput> escape prefix in &abbrev; version 3.0 and 3.1. In &abbrev; 3.2 and later, you can also use the <userinput>\x</userinput> escape prefix and the ASCII code of the character. For example, to filter on carriage returns, use the following filter:</para>
            <synopsis>filter f_carriage_return {match("\x0d" value ("MESSAGE"));};</synopsis>
        </section>
        <section xml:id="tagging-messages">
            <title>Tagging messages</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>tags</secondary>
            </indexterm>
            <indexterm>
                <primary>tagging messages</primary>
            </indexterm>
            <indexterm>
                <primary>tags</primary>
            </indexterm>
            <para>You can label the messages with custom tags. Tags are simple labels, identified by their names, which must be unique. Currently &abbrev; can tag a message at two different places:</para>
            <itemizedlist>
                <listitem>
                    <para>at the source when the message is received, and</para>
                </listitem>
                <listitem>
                    <para>when the message matches a pattern in the pattern database. For details on using the pattern database, see <xref linkend="configuring-pattern-databases"/>, for details on creating tags in the pattern database, see <xref linkend="reference-patterndb-schemes"/>.</para>
                </listitem>
                <listitem condition="ose">
                    <para>Tags can be also added and deleted using rewrite rules. For details, see <xref linkend="rewrite-tags"/>.</para>
                </listitem>
            </itemizedlist>
            <para>When syslog-ng receives a message, it automatically adds the <userinput>.source.&lt;id_of_the_source_statement&gt;</userinput> tag to the message. Use the <parameter>tags()</parameter> option of the source to add custom tags, and the <parameter>tags()</parameter> option of the filters to select only specific messages.</para>
            <note>
                <itemizedlist>
                    <listitem>
                        <para>Tagging messages and also filtering on the tags is very fast, much faster than other types of filters.</para>
                    </listitem>
                    <listitem>
                        <para>Tags are available locally, that is, if you add tags to a message on the client, these tags will not be available on the server.</para>
                    </listitem>
                    <listitem>
                        <para>To include the tags in the message, use the <parameter>${TAGS}</parameter> macro in a template. Alternatively, if you are using the IETF-syslog message format, you can include the <parameter>${TAGS}</parameter> macro in the <parameter>.SDATA.meta</parameter> part of the message. Note that the <parameter>${TAGS}</parameter> macro is available only in &abbrev; 3.1.1 and later.</para>
                    </listitem>
                </itemizedlist>
            </note>
            <para>For an example on tagging, see <xref linkend="example-tags-filtering"/>.</para>
        </section>
        <section xml:id="reference-filters">
            <title>Filter functions</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>reference</secondary>
            </indexterm>
            <para>The following functions may be used in the filter statement, as described in <xref linkend="filters"/>.</para>
            <xi:include href="../../shared/chunk/table-filter-functions.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-facility.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-filter.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-host.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-inlist.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-priority.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="reference-filters-match.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-message.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-netmask.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-netmask6.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-program.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-source.xml"/>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="filter-tags.xml"/>
        </section>
    </section>
    <section xml:id="example-dropping-messages">
        <title>Dropping messages</title>
        <indexterm>
            <primary>skipping messages</primary>
        </indexterm>
        <indexterm>
            <primary>dropping messages</primary>
        </indexterm>
        <indexterm>
            <primary>discarding messages</primary>
        </indexterm>
        <para>To skip the processing of a message without sending it to a destination, create a log statement with the appropriate filters, but do not include any destination in the statement, and use the <parameter>final</parameter> flag.</para>
        <example>
            <title>Skipping messages</title>
            <para>The following log statement drops all <parameter>debug</parameter> level messages without any further processing.</para>
            <synopsis>filter demo_debugfilter { level(debug); };
log { source(s_all); filter(demo_debugfilter); flags(final); };</synopsis>
        </example>
    </section>
</chapter>
