<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section
 [  <!ENTITY % entities SYSTEM "syslog-ng-entities.ent">
 %entities;]>
<section xml:id="syslog-ng-patterndb-using-parsers" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Using pattern parsers</title>
    <indexterm>
        <primary>pattern database</primary>
        <secondary>creating parsers</secondary>
    </indexterm>
    <indexterm>
        <primary>artificial ignorance</primary>
        <secondary>message classification</secondary>
    </indexterm>
    <indexterm>
        <primary>parsing messages</primary>
    </indexterm>
    <para>Pattern parsers attempt to parse a part of the message using rules specific to the type of the parser. Parsers are enclosed between @ characters. The syntax of parsers is the following:</para>
    <itemizedlist>
        <listitem>
            <para>a beginning <userinput>@</userinput> character;</para>
        </listitem>
        <listitem>
            <para>the type of the parser written in capitals;</para>
        </listitem>
        <listitem>
            <para>optionally a name;</para>
        </listitem>
        <listitem>
            <para>parameters of the parser, if any;</para>
        </listitem>
        <listitem>
            <para>a closing <userinput>@</userinput> character.</para>
        </listitem>
    </itemizedlist>
    <example>
        <title>Pattern parser syntax</title>
        <para>A simple parser:</para>
        <synopsis>@STRING@</synopsis>
        <para>A named parser:</para>
        <synopsis>@STRING:myparser_name@</synopsis>
        <para>A named parser with a parameter:</para>
        <synopsis>@STRING:myparser_name:*@</synopsis>
        <para>A parser with a parameter, but without a name:</para>
        <synopsis>@STRING::*@</synopsis>
    </example>
    <para>Patterns and literals can be mixed together. For example, to parse a message that begins with the <userinput>Host: </userinput> string followed by an IP address (for example, <userinput>Host: 192.168.1.1</userinput>), the following pattern can be used: <userinput>Host:@IPv4@</userinput>.</para>
    <note>
        <para>Note that using parsers is a CPU-intensive operation. Use the ESTRING and QSTRING parsers whenever possible, as these can be processed much faster than the other parsers.</para>
    </note>
    <example>
        <title>Using the STRING and ESTRING parsers</title>
        <para>For example, if the message is <userinput>user=joe96 group=somegroup</userinput>, <userinput>@STRING:mytext:@</userinput> parses only to the first non-alphanumeric character (<userinput>=</userinput>), parsing only <userinput>user</userinput>. <userinput>@STRING:mytext:=@</userinput> parses the equation mark as well, and proceeds to the next non-alphanumeric character (the whitespace), resulting in <userinput>user=joe96</userinput> being parsed. <userinput>@STRING:mytext:= @</userinput> will parse the whitespace as well, and proceed to the next non-alphanumeric non-equation mark non-whitespace character, resulting in <userinput>user=joe96 group=somegroup</userinput>.</para>
        <para>Of course, usually it is better to parse the different values separately, like this: <userinput>"user=@STRING:user@ group=@STRING:group@"</userinput>.</para>
        <para>If the username or the group may contain non-alphanumeric characters, you can either include these in the second parameter of the parser (as shown at the beginning of this example), or use an ESTRING parser to parse the message till the next whitespace: <userinput>"user=@ESTRING:user: @group=@ESTRING:group: @"</userinput>.</para>
    </example>
    <section xml:id="reference-patterndb-parsers">
        <title>Pattern parsers of &abbrev;</title>
        <para>The following parsers are available in &abbrev;.</para>
        <simplesect xml:id="patterndb-parser-anystring">
            <title>@ANYSTRING@</title>
            <indexterm type="parameter">
                <primary>@ANYSTRING@</primary>
            </indexterm>
            <para>Parses everything to the end of the message; you can use it to collect everything that is not parsed specifically to a single macro. In that sense its behavior is similar to the <parameter>greedy()</parameter> option of the CSV parser.</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-double">
            <title>@DOUBLE@</title>
            <para>An obsolete alias of the <parameter>@FLOAT@</parameter> parser.</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-estring">
            <title>@ESTRING@</title>
            <indexterm type="parameter">
                <primary>@ESTRING@</primary>
            </indexterm>
            <para>This parser has a required parameter that acts as the stopcharacter: the parser parses everything until it finds the stopcharacter. For example to stop by the next <userinput>"</userinput> (double quote) character, use <userinput>@ESTRING::"@</userinput>. To stop by a colon (:), the colon has to be escaped with another colon, like: <userinput>@ESTRING::::@</userinput>. As of &abbrev; <phrase condition="ose">3.1</phrase>, it is possible to specify a stopstring instead of a single character, for example, <userinput>@ESTRING::stop_here.@</userinput>. The <userinput>@</userinput> character cannot be a stopcharacter, nor can line-breaks or tabs.</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-float">
            <title>@FLOAT@</title>
            <indexterm type="parameter">
                <primary>@FLOAT@</primary>
            </indexterm>
            <para>A floating-point number that may contain a dot (.) character. (Up to syslog-ng 3.1, the name of this parser was <parameter>@DOUBLE@</parameter>.)</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-ipv4">
            <title>@IPv4@</title>
            <indexterm type="parameter">
                <primary>@IPv4</primary>
            </indexterm>
            <para>Parses an IPv4 IP address (numbers separated with a maximum of 3 dots).</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-ipv6">
            <title>@IPv6@</title>
            <indexterm type="parameter">
                <primary>@IPv6@</primary>
            </indexterm>
            <para>Parses any valid IPv6 IP address.</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-ipvany">
            <title>@IPvANY@</title>
            <indexterm type="parameter">
                <primary>@IPvANY@</primary>
            </indexterm>
            <para>Parses any IP address.</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-number">
            <title>@NUMBER@</title>
            <indexterm type="parameter">
                <primary>@NUMBER@</primary>
            </indexterm>
            <para>A sequence of decimal (0-9) numbers (for example, 1, 0687, and so on). Note that if the number starts with the 0x characters, it is parsed as a hexadecimal number, but only if at least one valid character follows 0x. A leading hyphen (<userinput>&ndash;</userinput>) is accepted for non-hexadecimal numbers, but other separator characters (for example, dot or comma) are not. To parse floating-point numbers, use the @FLOAT@ parser.</para>
        </simplesect>
        <simplesect xml:id="patterndb-parser-qstring">
            <title>@QSTRING@</title>
            <indexterm type="parameter">
                <primary>@QSTRING@</primary>
            </indexterm>
            <para>Parse a string between the quote characters specified as parameter. Note that the quote character can be different at the beginning and the end of the quote, for example: <userinput>@QSTRING::"@</userinput> parses everything between two quotation marks (<userinput>"</userinput>), while <userinput>@QSTRING:&amp;lt;&amp;gt;@</userinput> parses from an opening bracket to the closing bracket. The <userinput>@</userinput> character cannot be a quote character, nor can line-breaks or tabs.</para>
        </simplesect>
        <simplesect>
            <title>@STRING@</title>
            <indexterm type="parameter">
                <primary>@STRING@</primary>
            </indexterm>
            <para>A sequence of alphanumeric characters (0-9, A-z), not including any whitespace. Optionally, other accepted characters can be listed as parameters (for example, to parse a complete sentence, add the whitespace as parameter, like: <userinput>@STRING:: @</userinput>). Note that the <userinput>@</userinput> character cannot be a parameter, nor can line-breaks or tabs.</para>
        </simplesect>
    </section>
</section>
