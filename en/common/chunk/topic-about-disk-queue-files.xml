<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]>
<topic xmlns="http://docbook.org/ns/docbook" version="5.0">
    <simplesect>
        <title>Normal and reliable queue files</title>
        <para>The key difference between disk queue files that employ the <userinput>reliable(yes)</userinput> option and not is the strategy they employ. Reliable disk queues guarantee that all the messages passing through them are written to disk first, and removed from the queue only after the destination has confirmed that the message has been successfully received. This prevents message loss, for example, due to &abbrev; crashes if the client and the destination server communicate using the <trademark>Reliable Log Transfer Protocol</trademark> (<trademark>RLTP</trademark>). Note that the <trademark>Reliable Log Transfer Protocol</trademark> is available only in <phrase condition="ose"><link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="https://www.balabit.com/log-management-software/features?utm_source=documentation&amp;utm_medium=webhelp&amp;utm_campaign=ose">&pe;</link></phrase><phrase condition="pe"><link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="https://www.balabit.com/log-management-software/features?utm_source=documentation&amp;utm_medium=webhelp&amp;utm_campaign=pe">&pe;</link></phrase>. Of course, using the <userinput>reliable(yes)</userinput> option introduces a significant performance penalty as well. Reliable disk queues employ an in-memory cache buffer, the content of which is also written to the disk, and which is intended to speed up the process of reading back data from the queue.</para>
        <para>Normal disk queues work in a different way: they employ an in-memory output buffer (set in <parameter>qout-size()</parameter>) and an in-memory overflow queue (set in <parameter>mem-buf-length()</parameter>). The disk buffer file itself is only used if the overflow buffer is filled up completely. This approach has better performance (because of less disk IO operations), but also carries the risk of losing a maximum of <parameter>qout-size()</parameter> plus <parameter>mem-buf-length()</parameter> number of messages in case of an unexpected power failure or application crash.</para>
    </simplesect>
    <simplesect>
        <title>Size and truncation of queue files</title>
        <para>Disk queue files tend to grow. Each may take up to <parameter>disk-buf-size()</parameter> bytes on the disk. Due to the nature of reliable queue files, all the messages traversing the queue are written to disk, constantly increasing the size of the queue file. Truncation only occurs if the read and write heads of the queue reach the same position. Given that new messages arrive all the time, at least a small number of messages will almost always be stored in the queue file at all times. As a result, the queue file is not truncated automatically, but grows until it reaches the maximal configured size, after which the write head will wrap around, later followed by the read head.</para>
        <para>In case of normal disk queue files, growth in size is not so apparent, as the disk-based queue file is only used if the in-memory overflow buffer fills up. Once the destination sends messages faster than the incoming message rate, the queue will start to empty, and when the read and write heads of the queue reach the same position, the queue files are finally truncated.</para>
        <para>Note that if a queue file becomes corrupt, &abbrev; starts a new one. This might lead to the queue files consuming more space in total than their maximal configured size and the number of configured queue files multiplied together.</para>
    </simplesect>
</topic>
