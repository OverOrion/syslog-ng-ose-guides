<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter SYSTEM "../../xml-stylesheet/pdf/dtd/docbookx.dtd"
 [  
 <!ENTITY % entities SYSTEM "../../syslog-ng-admin-guide/syslog-ng-entities.ent">
 %entities;]> 
<chapter>
    <title/>
    <section id="patterndb-structure">
        <title>The structure of the pattern database</title>
        <indexterm>
            <primary>pattern database</primary>
            <secondary>structure of</secondary>
        </indexterm>
        <para>The pattern database is organized as follows:</para>
        <figure float="0">
            <title>The structure of the pattern database</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center" fileref="patterndb-structure.png"
                        scale="&webscreenshotscale;"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/patterndb-structure.png"
                        scale="50"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <para>The pattern database consists of rulesets. A ruleset consists of a Program
                    Pattern and a set of rules: the rules of a ruleset are applied to log messages
                    if the name of the application that sent the message matches the Program Pattern
                    of the ruleset. The name of the application (the content of the $PROGRAM macro)
                    is compared to the Program Patterns of the available rulesets, and then the
                    rules of the matching rulesets are applied to the message.</para>
            </listitem>
            <listitem>
                <para>The Program Pattern can be a string that specifies the name of the appliation
                    or the beginning of its name (for example, to match for sendmail, the program pattern
                    can be sendmail, or just send), and the Program Pattern can contain pattern
                    parsers. Note that pattern parsers are completely independent from the syslog-ng
                    parsers used to segment messages. Additionally, every rule has a unique
                    identifier: if a message matches a rule, the identifier of the rule is stored
                    together with the message.</para>
            </listitem>
            <listitem>
                <para>Rules consist of a message pattern and a class. The Message Pattern is similar
                    to the Program Pattern, but is applied to the message part of the log message
                    (the content of the $MESSAGE macro). If a message pattern matches the message,
                    the class of the rule is assigned to the message (for example, Security, Violation,
                    and so on).</para>
            </listitem>
            <listitem>
                <para>Rules can also contain additional information about the matching messages,
                    such as the description of the rule, an URL, name-value pairs, or free-form tags.<phrase
                        condition="ssb"> This information is displayed by the &product; in the
                        e-mail alerts (if alerts are requested for the rule), and are also displayed
                        on the search interface.</phrase></para>
            </listitem>
            <listitem>
                <para>Patterns can consist of literals (keywords, or rather, keycharacters) and
                    pattern parsers.</para>
                <note>
                    <para>If the $PROGRAM part of a message is empty, rules with an empty Program
                        Pattern are used to classify the message.</para>
                    <para>If the same Program Pattern is used in multiple rulesets, the rules of
                        these rulesets are merged, and every rule is used to classify the message.
                        Note that message patterns must be unique within the merged rulesets, but
                        the currently only one ruleset is checked for uniqueness.</para>
                </note>
            </listitem>
        </itemizedlist>
    </section>
    <section id="patterndb-operation">
        <title>How pattern matching works</title>
        <indexterm>
            <primary>pattern matching</primary>
            <secondary>procedure of</secondary>
        </indexterm>
        <figure float="0">
            <title>Applying patterns</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" align="center" fileref="patterndb-pattern.png"
                        scale="&webscreenshotscale;"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/patterndb-pattern.png" scale="50"
                    />
                </imageobject>
            </mediaobject>
        </figure>
        <para>The followings describe how patterns work. This information applies to program
            patterns and message patterns alike, even though message patterns are used to illustrate
            the procedure.</para>
        <para>Patterns can consist of literals (keywords, or rather, keycharacters) and pattern
            parsers. Pattern parsers attempt to parse a sequence of characters according to certain
            rules.</para>
        <note>
            <para>Wildcards and regular expressions cannot be used in patterns. The
                <parameter>@</parameter> character must be escaped, that is, to match for this
                character, you have to write <parameter>@@</parameter> in your pattern. This is
                required because pattern parsers of syslog-ng are enclosed between
                <parameter>@</parameter> characters.</para>
        </note>
        <indexterm>
            <primary>classifying messages</primary>
            <secondary>pattern matching concepts</secondary>
        </indexterm>
        <indexterm>
            <primary>pattern databases</primary>
            <secondary>pattern matching precedence</secondary>
        </indexterm>
        <para>When a new message arrives, syslog-ng attempts to classify it using the pattern
            database. The available patterns are organized alphabetically into a tree, and syslog-ng
            inspects the message character-by-character, starting from the beginning. This approach
            ensures that only a small subset of the rules must be evaluated at any given step,
            resulting in high processing speed. Note that the speed of classifying messages is
            practically independent from the total number of rules. </para>
        <para>For example, if the message begins with the <parameter>Apple</parameter> string, only
            patterns beginning with the character <parameter>A</parameter> are considered. In the
            next step, syslog-ng selects the patterns that start with <parameter>Ap</parameter>, and
            so on, until there is no more specific pattern left.</para>
        <para>Note that literal matches take precedence over pattern parser matches: if at a step
            there is a pattern that matches the next character with a literal, and another pattern
            that would match it with a parser, the pattern with the literal match is selected. Using
            the previous example, if at the third step there is the literal pattern
                <parameter>Apport</parameter> and a pattern parser
            <parameter>Ap@STRING@</parameter>, the <parameter>Apport</parameter> pattern is matched. If the literal does not match the incoming string (foe example, <parameter>Apple</parameter>), syslog-ng attempts to match the pattern with the parser. However, if there are two or more parsers on the same level, only the first one will be applied, even if it does not perfectly match the message.</para>
        <para>If there are two parsers at the same level (for example, <parameter>Ap@STRING@</parameter>
            and <parameter>Ap@QSTRING@</parameter>), it is random which pattern is applied
            (technically, the one that is loaded first). However, if the selected parser cannot
            parse at least one character of the message, the other parser is used. But having two
            different parsers at the same level is extremely rare, so the impact of this limitation
            is much less than it appears.</para>
    </section>
    <section id="patterndb-using-parsers">
        <title>Using pattern parsers</title>
        <indexterm>
            <primary>pattern database</primary>
            <secondary>creating parsers</secondary>
        </indexterm>
        <indexterm>
            <primary>artificial ignorance</primary>
            <secondary>message classification</secondary>
        </indexterm>
        <indexterm>
            <primary>parsing messages</primary>
        </indexterm>
        <para>Pattern parsers attempt to parse a part of the message using rules specific to the
            type of the parser. Parsers are enclosed between @ characters. The syntax of parsers is
            the following:</para>
        <itemizedlist>
            <listitem>
                <para>a beginning <parameter>@</parameter> character;</para>
            </listitem>
            <listitem>
                <para>the type of the parser written in capitals;</para>
            </listitem>
            <listitem>
                <para>optionally a name;</para>
            </listitem>
            <listitem>
                <para>parameters of the parser, if any;</para>
            </listitem>
            <listitem>
                <para>a closing <parameter>@</parameter> character.</para>
            </listitem>
        </itemizedlist>
        <example>
            <title>Pattern parser syntax</title>
            <para>A simple parser:</para>
            <synopsis>@STRING@</synopsis>
            <para>A named parser:</para>
            <synopsis>@STRING:myparser_name@</synopsis>
            <para>A named parser with a parameter:</para>
            <synopsis>@STRING:myparser_name:*@</synopsis>
            <para>A parser with a parameter, but without a name:</para>
            <synopsis>@STRING::*@</synopsis>
        </example>
        <para>The following parsers are available:</para>
        <itemizedlist>
            <listitem>
                <para><emphasis>@ANYSTRING@</emphasis>: Parses everything to the end of the message;
                    you can use it to collect everything that is not parsed specifically to a single
                    macro. In that sense its behavior is similar to the
                    <parameter>greedy()</parameter> option of the CSV parser.</para>
            </listitem>
            <listitem>
                <para><emphasis>@DOUBLE@</emphasis>: An obsolete alias of the
                    <parameter>@FLOAT@</parameter> parser.</para>
            </listitem>
            <listitem>
                <para><emphasis>@ESTRING@</emphasis>: This parser has a required parameter that acts
                    as the stopcharacter: the parser parses everything until it finds the
                    stopcharacter. For example to stop by the next <parameter>"</parameter> (double
                    quote) character, use <parameter>@ESTRING::"@</parameter>. To stop by a colon (:), the colon has to be escaped with another colon, like: <parameter>@ESTRING::::@</parameter>. As of syslog-ng 3.1,
                    it is possible to specify a stopstring instead of a single character, for example,
                        <parameter>@ESTRING::stop_here.@</parameter>. The
                    <parameter>@</parameter> character cannot be a stopcharacter, nor can line-breaks or
                    tabs.</para>
            </listitem>
            <listitem>
                <para><emphasis>@FLOAT@</emphasis>: A floating-point number that may contain a dot
                    (.) character. (Up to syslog-ng 3.1, the name of this parser was
                        <parameter>@DOUBLE@</parameter>.)</para>
            </listitem>
            <listitem>
                <para><emphasis>@IPv4@</emphasis>: Parses an IPv4 IP address (numbers separated with
                    a maximum of 3 dots).</para>
            </listitem>
            <listitem>
                <para><emphasis>@IPv6@</emphasis>: Parses any valid IPv6 IP address.</para>
            </listitem>
            <listitem>
                <para><emphasis>@IPvANY@</emphasis>: Parses any IP address.</para>
            </listitem>
            <listitem>
                <para><emphasis>@NUMBER@</emphasis>: A sequence of decimal (0-9) numbers (for example, 1,
                    0687, and so on). Note that if the number starts with the 0x characters, it is parsed
                    as a hexadecimal number, but only if at least one valid character follows
                0x.</para>
            </listitem>
            <listitem>
                <para><emphasis>@QSTRING@</emphasis>: Parse a string between the quote characters
                    specified as parameter. Note that the quote character can be different at the
                    beginning and the end of the quote, for example: <parameter>@QSTRING::"@</parameter>
                    parses everything between two quotation marks (<parameter>"</parameter>), while
                        <parameter>@QSTRING:&amp;lt;&amp;gt;@</parameter> parses from an opening
                    bracket to the closing bracket. The
                    <parameter>@</parameter> character cannot be a quote character, nor can line-breaks or
                    tabs.</para>
            </listitem>
            <listitem>
                <para><emphasis>@STRING@</emphasis>: A sequence of alphanumeric characters (0-9,
                    A-z), not including any whitespace. Optionally, other accepted characters can be
                    listed as parameters (for example, to parse a complete sentence, add the whitespace as
                    parameter, like: <parameter>@STRING:: @</parameter>). Note that the
                    <parameter>@</parameter> character cannot be a parameter, nor can line-breaks or
                    tabs.</para>
            </listitem>
        </itemizedlist>
        <!--<figure float="0" condition="ssb">
            <title>Sample message patterns</title>
            <mediaobject>
            <imageobject role="html">
            <imagedata format="PNG" align="center" fileref="ssb-patterndb-search.png"
            width="&webscreenshotscale;"/>
            </imageobject>
            <imageobject role="fo">
            <imagedata format="PNG" fileref="&imgroot;/ssb-patterndb-search.png"
            contentwidth="&screenshotsize;"/>
            </imageobject>
            </mediaobject>
            </figure>-->
        <para>Patterns and literals can be mixed together. For example, to parse a message that
            begins with the <parameter>Host: </parameter> string followed by an IP address (for example,
                <parameter>Host: 192.168.1.1</parameter>), the following pattern can be used:
                <parameter>Host:@IPv4@</parameter>.</para>
        <note>
            <para>Note that using parsers is a CPU-intensive operation. Use the ESTRING and QSTRING
                parsers whenever possible, as these can be processed much faster than the other
                parsers.</para>
        </note>
        <example>
            <title>Using the STRING and ESTRING parsers</title>
            <para>For example, if the message is <parameter>user=joe96 group=somegroup</parameter>,
                    <parameter>@STRING:mytext:@</parameter> parses only to the first
                non-alphanumeric character (<parameter>=</parameter>), parsing only
                <parameter>user</parameter>. <parameter>@STRING:mytext:=@</parameter> parses the
                equation mark as well, and proceeds to the next non-alphanumeric character (the
                whitespace), resulting in <parameter>user=joe96</parameter> being parsed.
                    <parameter>@STRING:mytext:= @</parameter> will parse the whitespace as well, and
                proceed to the next non-alphanumeric non-equation mark non-whitespace character,
                resulting in <parameter>user=joe96 group=somegroup</parameter>.</para>
            <para>Of course, usually it is better to parse the different values separately, like
                this: <parameter>"user=@STRING:user@ group=@STRING:group@"</parameter>.</para>
            <para>If the username or the group may contain non-alphanumeric characters, you can
                either include these in the second parameter of the parser (as shown at the
                beginning of this example), or use an ESTRING parser to parse the message till the
                next whitespace: <parameter>"user=@ESTRING:user: @group=@ESTRING:group:
                @"</parameter>.</para>
        </example>

    </section>

</chapter>
