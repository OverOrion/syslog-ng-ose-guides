<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body name="json-parser" oldrole="section">
        <h1 name="json-parser">The JSON parser</h1>
        <MadCap:keyword term="segmenting messages">
        </MadCap:keyword>
        <MadCap:keyword term="JSON parsers">
        </MadCap:keyword>
        <MadCap:keyword term="splitting messages">
        </MadCap:keyword>
        <MadCap:keyword term="parsers:['json-parser']">
        </MadCap:keyword>
        <p oldrole="para">JavaScript Object Notation (JSON) is a text-based open standard designed for human-readable data interchange. It is used primarily to transmit data between a server and web application, serving as an alternative to XML. It is described in <a href="https://tools.ietf.org/html/rfc4627">RFC 4627</a>. The <MadCap:variable name="General.abbrev"></MadCap:variable> application can separate parts of incoming JSON-encoded log messages to name-value pairs. For details on using value-pairs in <MadCap:variable name="General.abbrev"></MadCap:variable> see <MadCap:xref href="concepts-value-pairs.htm#concepts-value-pairs"></MadCap:xref>.</p>
        <p oldrole="para">You can refer to the separated parts of the JSON message using the key of the JSON object as a macro. For example, if the JSON contains <span class="Code" oldrole="userinput">{"KEY1":"value1","KEY2":"value2"}</span>, you can refer to the values as <span class="Code" oldrole="userinput">${KEY1}</span> and <span class="Code" oldrole="userinput">${KEY2}</span>. If the JSON content is structured, <MadCap:variable name="General.abbrev"></MadCap:variable> converts it to dot-notation-format. For example, to access the value of the following structure <span class="Code" oldrole="userinput">{"KEY1": {"KEY2": "VALUE"}}</span>, use the <span class="Code" oldrole="userinput">${KEY1.KEY2}</span> macro.</p>
        <table cellspacing="0" class="TableStyle-NoteTable_Yellow_DoNotEdit" oldrole="warning" style="width: 100%;mc-table-style: url('../../../Resources/TableStyles/NoteTable_Yellow_DoNotEdit.css');">
            <col class="TableStyle-NoteTable_Yellow_DoNotEdit-Column-Column1" style="width: 0.3in;">
            </col>
            <col class="TableStyle-NoteTable_Yellow_DoNotEdit-Column-Column2">
            </col>
            <tbody>
                <tr class="TableStyle-NoteTable_Yellow_DoNotEdit-Body-Body1">
                    <td class="TableStyle-NoteTable_Yellow_DoNotEdit-BodyB-Column1-Body1">
                        <p>
                            <img src="../../../Resources/Images/Common/caution.png" />
                        </p>
                    </td>
                    <td class="TableStyle-NoteTable_Yellow_DoNotEdit-BodyA-Column2-Body1"><span class="Yellow">Caution: </span>
                        <p oldrole="para">If the names of keys in the JSON content are the same as the names of <MadCap:variable name="General.abbrev"></MadCap:variable> soft macros, the value from the JSON content will overwrite the value of the macro. For example, the <span class="Code" oldrole="userinput">{"PROGRAM":"value1","MESSAGE":"value2"}</span> JSON content will overwrite the <span class="Code" oldrole="userinput">${PROGRAM}</span> and <span class="Code" oldrole="userinput">${MESSAGE}</span> macros. To avoid overwriting such macros, use the <span class="Code" oldrole="parameter">prefix()</span> option.</p>
                        <p oldrole="para">Hard macros cannot be modified, so they will not be overwritten. For details on the macro types, see <MadCap:xref href="macros-hard-vs-soft.htm#macros-hard-vs-soft"></MadCap:xref>.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <table cellspacing="0" class="TableStyle-NoteTable_Blue_DoNotEdit" oldrole="note" style="width: 100%;mc-table-style: url('../../../Resources/TableStyles/NoteTable_Blue_DoNotEdit.css');">
            <col class="TableStyle-NoteTable_Blue_DoNotEdit-Column-Column1" style="width: 0.3in;">
            </col>
            <col class="TableStyle-NoteTable_Blue_DoNotEdit-Column-Column2">
            </col>
            <tbody>
                <tr class="TableStyle-NoteTable_Blue_DoNotEdit-Body-Body1">
                    <td class="TableStyle-NoteTable_Blue_DoNotEdit-BodyB-Column1-Body1">
                        <p>
                            <img src="../../../Resources/Images/Common/note.png" />
                        </p>
                    </td>
                    <td class="TableStyle-NoteTable_Blue_DoNotEdit-BodyA-Column2-Body1"><span class="AllNoteStyles">NOTE: </span>
                        <p oldrole="para">The JSON parser currently supports only integer, double and string values when interpreting JSON structures. As syslog-ng does not handle different data types internally, the JSON parser converts all JSON data to string values. In case of boolean types, the value is converted to 'TRUE' or 'FALSE' as their string representation.</p>
                        <p oldrole="para">The JSON parser discards messages if it cannot parse them as JSON messages, so it acts as a JSON-filter as well.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p oldrole="para">To create a JSON parser, define a parser that has the <span class="Code" oldrole="parameter">json-parser()</span> option. Defining the prefix and the marker are optional. By default, the parser will process the <span class="Code" oldrole="userinput">${MESSAGE}</span> part of the log message. To process other parts of a log message with the JSON parser, use the <span class="Code" oldrole="parameter">template()</span> option. You can also define the parser inline in the log path.</p>
        <h6 oldrole="formalpara">Declaration:</h6><pre class="Code" oldrole="synopsis">parser parser_name {
    json-parser(
        marker()
        prefix()
    );
};</pre>
        <div class="Example">
            <h6 oldrole="example">Example: Using a JSON parser</h6>
            <p oldrole="para">In the following example, the source is a JSON encoded log message. The syslog parser is disabled, so that <MadCap:variable name="General.abbrev"></MadCap:variable> does not parse the message: <span class="Code" oldrole="userinput">flags(no-parse)</span>. The json-parser inserts "<span class="Code" oldrole="userinput">.json.</span>" prefix before all extracted name-value pairs. The destination is a file, that uses the <span class="Code" oldrole="parameter">format-json</span> template function. Every name-value pair that begins with a dot ("<span class="Code" oldrole="userinput">.</span>") character will be written to the file (<span class="Code" oldrole="userinput">dot-nv-pairs</span>). The log line connects the source, the destination and the parser.</p><pre class="Code" oldrole="synopsis">source s_json {
    network(port(21514) flags(no-parse));
};

destination d_json {
    file("/tmp/test.json"
        template("$(format-json --scope dot-nv-pairs)\n"));
};

parser p_json {
    json-parser (prefix(".json."));
};

log {
    source(s_json);
    parser(p_json);
    destination(d_json);
};</pre>
            <p oldrole="para">You can also define the parser inline in the log path.</p><pre class="Code" oldrole="synopsis">source s_json {
    network(port(21514) flags(no-parse));
};

destination d_json {
    file("/tmp/test.json"
        template("$(format-json --scope dot-nv-pairs)\n"));
};

log {
    source(s_json);
    parser {
        json-parser (prefix(".json."));
    };
    destination(d_json);
};</pre>
        </div>
    </body>
</html>