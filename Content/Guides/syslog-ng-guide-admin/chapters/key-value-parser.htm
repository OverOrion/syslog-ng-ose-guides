<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body name="key-value-parser" oldrole="section">
        <h1 name="key-value-parser">Parsing <span class="Code" oldrole="userinput">key=value</span> pairs</h1>
        <MadCap:keyword term="segmenting messages">
        </MadCap:keyword>
        <MadCap:keyword term="key=value pairs">
        </MadCap:keyword>
        <MadCap:keyword term="key-value pairs">
        </MadCap:keyword>
        <MadCap:keyword term="splitting messages">
        </MadCap:keyword>
        <MadCap:keyword term="parsers:['kv-parser']">
        </MadCap:keyword>
        <p oldrole="para">The <MadCap:variable name="General.abbrev"></MadCap:variable> application can separate a message consisting of whitespace or comma-separated <span class="Code" oldrole="userinput">key=value</span> pairs (for example, Postfix log messages) into name-value pairs. You can also specify other separator character instead of the equal sign, for example, colon (<span class="Code" oldrole="userinput">:</span>) to parse MySQL log messages. The <MadCap:variable name="General.abbrev"></MadCap:variable> application automatically trims any leading or trailing whitespace characters from the keys and values, and also parses values that contain unquoted whitespace. For details on using value-pairs in <MadCap:variable name="General.abbrev"></MadCap:variable> see <MadCap:xref href="concepts-value-pairs.htm#concepts-value-pairs"></MadCap:xref>.</p>
        <p oldrole="para">You can refer to the separated parts of the message using the key of the value as a macro. For example, if the message contains <span class="Code" oldrole="userinput">KEY1=value1,KEY2=value2</span>, you can refer to the values as <span class="Code" oldrole="userinput">${KEY1}</span> and <span class="Code" oldrole="userinput">${KEY2}</span>.</p>
        <MadCap:snippetBlock src="../../shared/wnt/n-kv-parser-repeated-keys.htm">
        </MadCap:snippetBlock>
        <table cellspacing="0" class="TableStyle-NoteTable_Yellow_DoNotEdit" oldrole="warning" style="width: 100%;mc-table-style: url('../../../Resources/TableStyles/NoteTable_Yellow_DoNotEdit.css');">
            <col class="TableStyle-NoteTable_Yellow_DoNotEdit-Column-Column1" style="width: 0.3in;">
            </col>
            <col class="TableStyle-NoteTable_Yellow_DoNotEdit-Column-Column2">
            </col>
            <tbody>
                <tr class="TableStyle-NoteTable_Yellow_DoNotEdit-Body-Body1">
                    <td class="TableStyle-NoteTable_Yellow_DoNotEdit-BodyB-Column1-Body1">
                        <p>
                            <img src="../../../Resources/Images/Common/caution.png" />
                        </p>
                    </td>
                    <td class="TableStyle-NoteTable_Yellow_DoNotEdit-BodyA-Column2-Body1"><span class="Yellow">Caution: </span>
                        <p oldrole="para">If the names of keys in the message are the same as the names of <MadCap:variable name="General.abbrev"></MadCap:variable> soft macros, the value from the parsed message will overwrite the value of the macro. For example, the <span class="Code" oldrole="userinput">PROGRAM=value1, MESSAGE=value2</span> content will overwrite the <span class="Code" oldrole="userinput">${PROGRAM}</span> and <span class="Code" oldrole="userinput">${MESSAGE}</span> macros. To avoid overwriting such macros, use the <span class="Code" oldrole="parameter">prefix()</span> option.</p>
                        <p oldrole="para">Hard macros cannot be modified, so they will not be overwritten. For details on the macro types, see <MadCap:xref href="macros-hard-vs-soft.htm#macros-hard-vs-soft"></MadCap:xref>.</p>
                        <p oldrole="para">The parser discards message sections that are not <span class="Code" oldrole="userinput">key=value</span> pairs, even if they appear between <span class="Code" oldrole="userinput">key=value</span> pairs that can be parsed.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p oldrole="para">To parse <span class="Code" oldrole="userinput">key=value</span> pairs, define a parser that has the <span class="Code" oldrole="parameter">kv-parser()</span> option. Defining the prefix is optional. By default, the parser will process the <span class="Code" oldrole="userinput">${MESSAGE}</span> part of the log message. You can also define the parser inline in the log path.</p>
        <h6 oldrole="formalpara">Declaration:</h6><pre class="Code" oldrole="synopsis">parser parser_name {
    kv-parser(
        prefix()
    );
};</pre>
        <div class="Example">
            <h6 oldrole="example">Example: Using a <span class="Code" oldrole="userinput">key=value</span> parser</h6>
            <p oldrole="para">In the following example, the source is a log message consisting of comma-separated <span class="Code" oldrole="userinput">key=value</span> pairs, for example, a Postfix log message:</p><pre class="Code" oldrole="synopsis">Jun 20 12:05:12 mail.example.com &lt;info&gt; postfix/qmgr[35789]: EC2AC1947DA: from=&lt;me@example.com&gt;, size=807, nrcpt=1 (queue active)</pre>
            <p oldrole="para">The kv-parser inserts the "<span class="Code" oldrole="userinput">.kv.</span>" prefix before all extracted name-value pairs. The destination is a file, that uses the <span class="Code" oldrole="parameter">format-json</span> template function. Every name-value pair that begins with a dot ("<span class="Code" oldrole="userinput">.</span>") character will be written to the file (<span class="Code" oldrole="userinput">dot-nv-pairs</span>). The log line connects the source, the destination and the parser.</p><pre class="Code" oldrole="synopsis">source s_kv {
    network(port(21514));
};

destination d_json {
    file("/tmp/test.json"
        template("$(format-json --scope dot-nv-pairs)\n"));
};

parser p_kv {
    kv-parser (prefix(".kv."));
};

log {
    source(s_kv);
    parser(p_kv);
    destination(d_json);
};</pre>
            <p oldrole="para">You can also define the parser inline in the log path.</p><pre class="Code" oldrole="synopsis">source s_kv {
    network(port(21514));
};

destination d_json {
    file("/tmp/test.json"
        template("$(format-json --scope dot-nv-pairs)\n"));
};

log {
    source(s_kv);
    parser {
        kv-parser (prefix(".kv."));
    };
    destination(d_json);
};</pre>
            <p oldrole="para">You can set the separator character between the key and the value to parse for example <span class="Code" oldrole="userinput">key:value</span> pairs, like MySQL logs:</p><pre class="Code" oldrole="synopsis">Mar  7 12:39:25 myhost MysqlClient[20824]: SYSTEM_USER:'oscar', MYSQL_USER:'my_oscar', CONNECTION_ID:23, DB_SERVER:'127.0.0.1', DB:'--', QUERY:'USE test;'</pre><pre class="Code" oldrole="synopsis">parser p_mysql { kv-parser(value-separator(":") prefix(".mysql."));</pre>
        </div>
    </body>
</html>